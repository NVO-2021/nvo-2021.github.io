<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[elastic-job源码浅析-架构篇]]></title>
    <url>%2F2018%2F10%2F25%2Felastic-job%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E6%9E%B6%E6%9E%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[源码阅读小技巧传送门1.写在前面elastic-job是当当开源的一款非常好用的作业框架，在此之前，任务调度的主流框架是quartZ或者spring-task。两者均不能很好地支持高并发量的分布式任务调度，即使是号称拥有集群能力的quartZ也仅仅保证了job的高可用，单一时刻只能有一台机器执行具体的调度任务。因此，老牌劲旅无法解决两个迫切的需求点：1.quartZ的集群仅仅是用于实现HA（high avalible),无法实现高并发；2.无论quartZ还是spring-task，均无法很好地实现水平拓展；1Elastic-Job is a distributed scheduled job framework, based on Quartz and Zookeeper.上述文字是elastic-job github主页对它的描述，从上面的描述中我们可以看到两个关键字Quartz和Zookeeper，基于以上两个基础框架，Elastic-job实现了高可用和高并发。2.elastic-job解决了那些问题举个典型的job场景，比如余额宝里的昨日收益，系统需要job在每天某个时间点开始，给所有余额宝用户计算收益。如果用户数量不多，我们可以轻易使用quartz来完成，我们让计息job在某个时间点开始执行，循环遍历所有用户计算利息，这没问题。可是，如果用户体量特别大，我们可能会面临着在第二天之前处理不完这么多用户。另外，我们部署job的时候也得注意，我们可能会把job直接放在我们的webapp里，webapp通常是多节点部署的，这样，我们的job也就是多节点，多个job同时执行，很容易造成重复执行，比如用户重复计息，为了避免这种情况，我们可能会对job的执行加锁，保证始终只有一个节点能执行，或者干脆让job从webapp里剥离出来，独自部署一个节点。elastic-job就可以帮助我们解决上面的问题，elastic底层的任务调度还是使用的quartz，通过zookeeper来动态给job节点分片。我们来看：很大体量的用户需要在特定的时间段内计息完成我们肯定是希望我们的任务可以通过集群达到水平扩展，集群里的每个节点都处理部分用户，不管用户数量有多庞大，我们只要增加机器就可以了，比如单台机器特定时间能处理n个用户，2台机器处理2n个用户，3台3n，4台4n…，再多的用户也不怕了。使用elastic-job开发的作业都是zookeeper的客户端，比如我希望3台机器跑job，我们将任务分成3片，框架通过zk的协调，最终会让3台机器分别分配到0,1,2的任务片，比如server0–&gt;0，server1–&gt;1，server2–&gt;2，当server0执行时，可以只查询id%3==0的用户，server1执行时，只查询id%3==1的用户，server2执行时，只查询id%3==2的用户。任务部署多节点引发重复执行在上面的基础上，我们再增加server3，此时，server3分不到任务分片，因为只有3片，已经分完了。没有分到任务分片的作业程序将不执行。如果此时server2挂了，那么server2的分片项会分配给server3，server3有了分片，就会替代server2执行。如果此时server3也挂了，只剩下server0和server1了，框架也会自动把server3的分片随机分配给server0或者server1，可能会这样，server0–&gt;0，server1–&gt;1,2。这种特性称之为弹性扩容，即elastic-job名称的由来。上述的引用比较冗长，简单地理解就是elastic-job利用zk的分布式集群管理能力，对job节点进行的弹性扩容和收缩。同时任务分片的方式保证了job执行的并发能力和防止重复执行，使任务调度不仅拥有高可用，也具备了水平拓展和高并发能力。3.elastic-job结构3.2 elastic-job架构图3.3 任务节点数据结构4.elastic-job模块简析core的主要的模块分为:job模块：plugin(内含三种不同的作业类型,分片策略)，api(对外暴露的api服务)，exception(异常类)，internal(内部模块)reg(注册中心)模块：base(基类)，异常处理模块，zookeeper注册中心模块]]></content>
      <tags>
        <tag>elastic-job</tag>
        <tag>源码</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo优化攻略]]></title>
    <url>%2F2018%2F10%2F25%2Fhexo%E4%BC%98%E5%8C%96%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[写在前面这个攻略主要是给有一定diy能力的hexo博主。一些细节的攻略可以参考如下文章：hexo 基础配置优化插件进阶静态代码压缩文章比较长的情况下网页往往会显示地较慢。因此，需要对静态代码进行压缩，以提高网站的响应速度。1npm install hexo-all-minifier --save在hexo根目录下的_config.yml中配置:12345678910111213141516171819202122232425262728# 代码压缩 github.com/chenzhutian/hexo-all-minifierall_minifier: truehtml_minifier: enable: true ignore_error: false exclude: css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: false # 图片不压缩 interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false文章加密插件安装1npm install hexo-encrypt --save在项目_config.yml中声名默认密码123#该密码为全局默认密码encrypt: password: 你的密码在文章头加入密码配置12encrypt: trueenc_pwd: 你的文章独立密码在根目录的package.json中追加配置，记得补全“,”1"hexo-encrypt": "^0.2.0"最终效果网站顶部进度条在{hexo-path}/themes/next/layout/_partials/head/head.swig中顶部加入如下代码123456789101112131415&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;&lt;style&gt;.pace .pace-progress &#123; background: #f6a427; /*进度条颜色*/ height: 3px;&#125;.pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/&#125;.pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/&#125;&lt;/style&gt;效果图利益相关转载请注明出处，否则我也拿你没办法。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>优化</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于装修的一点想法]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%85%B3%E4%BA%8E%E8%A3%85%E4%BF%AE%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[装修风格的讨论在这个宅基地很难批准的时候，终于可以造房子了。楼房的样式是那种两层平层 + 一层别墅式的样子，虽然比不上欧式的新颖，但是空间足够大，四平八稳的风格还算能接受。对于装修风格，和瓢羹同学也有一些讨论。一开始瓢羹同学认为欧式的辉煌装修风格不错，但是我觉得有点老土。于是呢，她说北欧性冷风不错，我也觉得可以，只是美中不足的是有点暗色调，不适合居家。我呢，有点青睐于和风的风格，比较的小资。但是，作为自建房格调又显得有点小气了。所以，经过一番博弈，我们最终把两种风格进行了mix——其实我们不是一定青睐和风，亦或是北欧。后来我们发现，我们只是对原木风比较感冒。原木材质的纹理，配合较大空间的色彩搭配，整体给人一种居家的舒适感和归属感。同时，又比较有格调。要准备的工作从目前来看打的轮廓和格局已经敲定了，但是整体装修的渲染还没出来，准备抽空到酷家乐搞一波装修效果图。到时候看看整体下来的装修效果如何。装修资料酷家乐 有好几套比较合理的和风装修来自酷家乐，吊顶采用了比较简约的纯白+造型别致的灯具，这个风格我们都比较喜欢。易盖房 小别墅一些样式比较讨巧，看着比较舒服。利益相关此文涉及的资料均无利益相关。如若转载请注明出处！]]></content>
      <tags>
        <tag>酷玩</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员养生秘笈]]></title>
    <url>%2F2018%2F10%2F21%2F%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%85%BB%E7%94%9F%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>程序员</tag>
        <tag>养生</tag>
        <tag>码农</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 源码阅读]]></title>
    <url>%2F2018%2F10%2F19%2Fspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[对于spring源码的一些个人的见解！！！spring 核心代码12345参考资料：spring源码深度解析Spring版本：Spring-4.3.5-RELEASE吐槽下，老外写的东西真晕啊，像亲妈一样啰啰嗦嗦帮你考虑了各种情况，然后最好还不忘加一句：如果你不满意，还可以拓展！！！核心流程初始化过程非常清晰的模板方法，每一个步骤封装成一个具体的函数进行代理，职责清晰明了；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //预热，做准备工作 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //获取内部的bean factory ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //预热beanFactory prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //beanFactory在上下文中注册bean，核心的代码就在这里 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // bean创建的时候拦截并注册bean处理器，这里只创建处理器，真正的创建是在getBean(..)方法里 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 用于支持国际化，比如一些日志的国际化匹配等； initMessageSource(); // 为上下文初始化消息传播工具 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 钩子方法：额外的beans处理方法 onRefresh(); // Check for listener beans and register them. // 注册监听器 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化非延时加载的bean单例 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // push beans创建完成的消息 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125;spring 类加载的基本类spring DefaultListableBeanFactory UML示意图：spring bean 创建过程转换beanName尝试从缓存中获取单例bean本身的实例化原型模式依赖检测parentBeanFactory 检测将gernerecBeanDefinition 转换成 RootBeanDefination寻找依赖根据scope 初始化(init)对应的bean类型转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/** * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve * @param requiredType the required type of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @param typeCheckOnly whether the instance is obtained for a type check, * not for actual use * @return an instance of the bean * @throws BeansException if the bean could not be created */@SuppressWarnings(&quot;unchecked&quot;)protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //转换beanName，我们知道在spring中，bean factory的名称都是类似于 &amp;org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory //因此获取的时候需要进行转换 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // 尝试从缓存中获取单例 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; &#125; //实例化 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Fail if we&apos;re already creating this bean instance: // We&apos;re assumably within a circular reference. // 检测当前依赖的类是否正在创建，如果是，则抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. // 如果bean配置不存在则只能去父工厂找 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; //转换并合并BeanDefinition属性 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 原型模式的bean需要循环检测依赖 防止出现A-&gt;B-&gt;A 的循环依赖情况出现 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &apos;&quot; + beanName + &quot;&apos; and &apos;&quot; + dep + &quot;&apos;&quot;); &#125; registerDependentBean(dep, beanName); getBean(dep); &#125; &#125; // Create bean instance. // 创建bean实例 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It&apos;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot; + scopeName + &quot;&apos;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; consider &quot; + &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. // 转换bean类型 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125;spring事务隔离级别及事务传播实现propagation_requierd(spring的事务默认是该级别)：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 * Create a TransactionStatus for an existing transaction. */private TransactionStatus handleExistingTransaction( TransactionDefinition definition, Object transaction, boolean debugEnabled) throws TransactionException &#123; //若为非事务方式，则抛异常 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123; throw new IllegalTransactionStateException( &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;); &#125; // 若存在事务，挂起适当前事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123; if (debugEnabled) &#123; logger.debug(&quot;Suspending current transaction&quot;); &#125; // 挂起当前事务 Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources); &#125; // 挂起当前事务，并新建事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123; if (debugEnabled) &#123; logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; + definition.getName() + &quot;]&quot;); &#125; //挂起当前事务 SuspendedResourcesHolder suspendedResources = suspend(transaction); try &#123; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); // 重新开启事务 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; &#125; catch (RuntimeException beginEx) &#123; resumeAfterBeginException(transaction, suspendedResources, beginEx); throw beginEx; &#125; catch (Error beginErr) &#123; resumeAfterBeginException(transaction, suspendedResources, beginErr); throw beginErr; &#125; &#125; // 若当前事务存在，则嵌套执行事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; if (!isNestedTransactionAllowed()) &#123; throw new NestedTransactionNotSupportedException( &quot;Transaction manager does not allow nested transactions by default - &quot; + &quot;specify &apos;nestedTransactionAllowed&apos; property with value &apos;true&apos;&quot;); &#125; if (debugEnabled) &#123; logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;); &#125; // 判定是否支持事务备份点 if (useSavepointForNestedTransaction()) &#123; // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); // 创建备份点 status.createAndHoldSavepoint(); return status; &#125; else &#123; // Nested transaction through nested begin and commit/rollback calls. // Usually only for JTA: Spring synchronization might get activated here // in case of a pre-existing JTA transaction. boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, null); // 不支持备份点的情况下会新建事务 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; &#125; &#125; // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED. if (debugEnabled) &#123; logger.debug(&quot;Participating in existing transaction&quot;); &#125; if (isValidateExistingTransaction()) &#123; if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123; Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel(); if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123; Constants isoConstants = DefaultTransactionDefinition.constants; throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; + definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; + (currentIsolationLevel != null ? isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) : &quot;(unknown)&quot;)); &#125; &#125; if (!definition.isReadOnly()) &#123; if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123; throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; + definition + &quot;] is not marked as read-only but existing transaction is&quot;); &#125; &#125; &#125; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);&#125;一些干货aop注入的实现过程doCreateBean中会暴露一个bean引用，用以处理循环引用；同时大家熟知的AOP就是通过getEarlyBeanReference(..)方法植入的；具体的，是在wrapIfNecessary(..) 方法中封装了advice并创建了代理；@Autowired注解的实现doCreateBean(..)中的populateBean(..)方法，实现了基于@Autowired注解的实现，根据名称或类型进行依赖的注入；]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Mvc源码阅读]]></title>
    <url>%2F2018%2F10%2F19%2Fspringmvc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[对springMVC的一些思考!!!Spring Mvc源码阅读12345678910111213SpringMVC核心处理流程：1、DispatcherServlet前端控制器接收发过来的请求，交给HandlerMapping处理器映射器2、HandlerMapping处理器映射器，根据请求路径找到相应的HandlerAdapter处理器适配器（处理器适配器就是那些拦截器或Controller）3、HandlerAdapter处理器适配器，请求数据绑定和转换，处理一些功能请求，返回一个ModelAndView对象（包括模型数据、逻辑视图名）4、ViewResolver视图解析器，先根据ModelAndView中设置的View解析具体视图5、然后再将Model模型中的数据渲染到View上这些过程都是以DispatcherServlet为中轴线进行的。入口源码springMVC的请求会交由dispatcherServlet处理，其本质上是一个多线程的请求处理机制；核心业务逻辑被设计在doDispatcher(..)方法中；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 绑定url -&gt; 具体的handler/Controller.method(..) // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 根据handler绑定具体的adapter // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = "GET".equals(method); if (isGet || "HEAD".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // interceptor 拦截器进行前置预处理 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 在handle方法中进行了请求数据的绑定，方法invoke，返回model的处理和封装等 // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException("Handler dispatch failed", err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125;核心关注的几个问题请求如何路由到具体的Controller上的方法进行处理?根据请求路径，与已知的handlerMapping进行匹配，并加入interceptors:dispatcherServlet.getHandler()最终调用AbstracteHandlerMapping.getHandlerExecutionChain(..)中进行url与handlerMapping进行匹配，并加入interceptors;扁平化的前端请求数据如何进行数据绑定？我们知道，前端的get/post等请求，会被requestServlet接受，并封装成HttpServletRequest的parameterMap中，每一项请求的数据结构都是 K-V 形的。而我们知道，像这样的形式，那么在这个中间数据如何实现数据绑定到Bean，String格式的Value 转换成各种目标格式。事实上，spring MVC将整个网络请求的处理流程进行了合理的切分,其大致的处理流程如下：12345678910111.调用匹配到的adapter.handle(..)2.然后调用invokeAndHandle(..)3.调用invokeForRequest(..)获取getMethodArgumentValues(..)获取和绑定入参;4.在具体的方法中，获取支持处理的argumentResolvers,然后调用resolveArgument(..)方法;5.在ModelAttributeMethodProcessor中调用bindRequestParameters(binder, webRequest),方法，然后再调用bind()进行bean参数的绑定；6.调用binder.convertIfNecessary(arg, parameter.getParameterType(), parameter)方法进行参数的转换；]]></content>
      <tags>
        <tag>Spring MVC</tag>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
</search>
