<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[程序员养生秘笈]]></title>
    <url>%2F2018%2F10%2F21%2F%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%85%BB%E7%94%9F%2F</url>
    <content type="text"><![CDATA[程序员养生秘笈 没去过地中海，头顶却成了地中海人未至中年,可是发际线却逐年上移。去年的发际线还被人形容为额头高，今年已经福尔康了。要说程序员的苦，那可真的不是一般的苦。 项目上线周期紧，拼命加班害怕完不成任务。好不容易做完上线了，可是明明测试环境妥妥的，一到上线就翻车……诸如此类的问题零零总总，对于初入码农界的萌新来说简直惶惶不可终日，知道发际线开始上移。 没错，其实前面描述的加班经历就是卤煮的真实历程，相信也是绝大部分耕耘在互联网界的同仁的心声。江湖上有句话————“穷则思变”。整天惶惶不可终日对一个人的发展是很不利的，尤其会消耗一个人大量的精力和耐心。所以，有没有什么方式可以规避？ 佛系撸代码在代码界有一个潜移默化的理论————二八理论。说人话就是20%的精英拿着比80%的普通人更高的薪水；一项业务20%的代码却起着80%的作用。言下之意，20%的精英写的20%的代码发挥着全局80%的效用，所以他们也配拿超过80%的人的薪水。 退一步讲，对于普通的码农来说，撸代码可能虽然辛苦，但很有可能只发挥了20%的作用，因此，你还会害怕上线出问题？即使出了问题，也不会导致非常重大的故障，所以，绝大部分情况下做大胆大心细，佛系淡定撸代码，保你头发乌黑靓丽，牙口倍儿棒，身体倍儿好！ 为啥只有我在加班？有些朋友老是会抱怨，为啥老是我在加班，别的同事早就干完活了。相信在互联网圈子里，工作强度大是一件常事，但是即使强度大，也该有应对的方法论。否则不仅公司里要加班，可能回到家还得接着加班才能赶上项目进度。是什么导致了加班？ 前期需求沟通不合理，导致任务的工作强度被严重低估，导致实际开发过程中发现时间根本不够。如果是这类情况，二话不说找产品小姐姐喝几杯时下流行的Luckin咖啡，有时好商量嘛。如果deadline已经确定了，一个人完不成赶紧找外援啊。毕竟，互联网圈时间就是everything啊！ 自身原因。比如工作没有很好的规划，就会导致后期码代码的时候没有思路。其实真正在撸代码的时间可能只占50%，前期的需求沟通，了解产品设计的整体结构和来龙去脉，再根据细节和流程设计代码显得非常之重要！ 多看看开源项目；在之前的工作过程中，有很多数据库的操作还是mybatis+手写sql的xml这类原始模式。知道有一天知道了tk.mybatis这个开源你的单表CRUD框架。从此，妈妈再也不担心我加班了。所以，多阅读开源框架，在项目的适当位置引用进来可以起到事半功倍的效果。 再一个就是要阅读一些常用框架的源码，其实很多面试java的萌新会问为什么要看源码，我光会写业务代码就行了啊。但是如果你不了解一个框架而滥用，可能会导致很严重的后果。比如，不知道dubbo invoke 的几种方式，可能会导致幂等性遭到破坏，数据就会发生不可预知的异常情况。另一个原因呢，是一些常用代码框架中常常有一些点睛之笔，可以完善你的代码事业，提升你的代码品味，从而写出高效而优雅的代码来！]]></content>
      <tags>
        <tag>程序员</tag>
        <tag>养生</tag>
        <tag>码农</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 源码阅读]]></title>
    <url>%2F2018%2F10%2F19%2Fspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[spring 核心代码 12345参考资料：spring源码深度解析Spring版本：Spring-4.3.5-RELEASE吐槽下，老外写的东西真晕啊，像亲妈一样啰啰嗦嗦帮你考虑了各种情况，然后最好还不忘加一句：如果你不满意，还可以拓展！！！ 核心流程初始化过程非常清晰的模板方法，每一个步骤封装成一个具体的函数进行代理，职责清晰明了；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //预热，做准备工作 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //获取内部的bean factory ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //预热beanFactory prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //beanFactory在上下文中注册bean，核心的代码就在这里 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // bean创建的时候拦截并注册bean处理器，这里只创建处理器，真正的创建是在getBean(..)方法里 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 用于支持国际化，比如一些日志的国际化匹配等； initMessageSource(); // 为上下文初始化消息传播工具 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 钩子方法：额外的beans处理方法 onRefresh(); // Check for listener beans and register them. // 注册监听器 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化非延时加载的bean单例 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // push beans创建完成的消息 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &apos;active&apos; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&apos;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; spring 类加载的基本类spring DefaultListableBeanFactory UML示意图： spring bean 创建过程 转换beanName 尝试从缓存中获取单例 bean本身的实例化 原型模式依赖检测 parentBeanFactory 检测 将gernerecBeanDefinition 转换成 RootBeanDefination 寻找依赖 根据scope 初始化(init)对应的bean 类型转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/** * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve * @param requiredType the required type of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @param typeCheckOnly whether the instance is obtained for a type check, * not for actual use * @return an instance of the bean * @throws BeansException if the bean could not be created */@SuppressWarnings(&quot;unchecked&quot;)protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //转换beanName，我们知道在spring中，bean factory的名称都是类似于 &amp;org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory //因此获取的时候需要进行转换 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // 尝试从缓存中获取单例 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;); &#125; else &#123; logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;); &#125; &#125; //实例化 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Fail if we&apos;re already creating this bean instance: // We&apos;re assumably within a circular reference. // 检测当前依赖的类是否正在创建，如果是，则抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. // 如果bean配置不存在则只能去父工厂找 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; //转换并合并BeanDefinition属性 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 原型模式的bean需要循环检测依赖 防止出现A-&gt;B-&gt;A 的循环依赖情况出现 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &apos;&quot; + beanName + &quot;&apos; and &apos;&quot; + dep + &quot;&apos;&quot;); &#125; registerDependentBean(dep, beanName); getBean(dep); &#125; &#125; // Create bean instance. // 创建bean实例 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It&apos;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot; + scopeName + &quot;&apos;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; consider &quot; + &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. // 转换bean类型 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; spring事务隔离级别及事务传播实现 propagation_requierd(spring的事务默认是该级别)：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。 propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。 propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。 propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 * Create a TransactionStatus for an existing transaction. */private TransactionStatus handleExistingTransaction( TransactionDefinition definition, Object transaction, boolean debugEnabled) throws TransactionException &#123; //若为非事务方式，则抛异常 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123; throw new IllegalTransactionStateException( &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;); &#125; // 若存在事务，挂起适当前事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123; if (debugEnabled) &#123; logger.debug(&quot;Suspending current transaction&quot;); &#125; // 挂起当前事务 Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources); &#125; // 挂起当前事务，并新建事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123; if (debugEnabled) &#123; logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; + definition.getName() + &quot;]&quot;); &#125; //挂起当前事务 SuspendedResourcesHolder suspendedResources = suspend(transaction); try &#123; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); // 重新开启事务 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; &#125; catch (RuntimeException beginEx) &#123; resumeAfterBeginException(transaction, suspendedResources, beginEx); throw beginEx; &#125; catch (Error beginErr) &#123; resumeAfterBeginException(transaction, suspendedResources, beginErr); throw beginErr; &#125; &#125; // 若当前事务存在，则嵌套执行事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; if (!isNestedTransactionAllowed()) &#123; throw new NestedTransactionNotSupportedException( &quot;Transaction manager does not allow nested transactions by default - &quot; + &quot;specify &apos;nestedTransactionAllowed&apos; property with value &apos;true&apos;&quot;); &#125; if (debugEnabled) &#123; logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;); &#125; // 判定是否支持事务备份点 if (useSavepointForNestedTransaction()) &#123; // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); // 创建备份点 status.createAndHoldSavepoint(); return status; &#125; else &#123; // Nested transaction through nested begin and commit/rollback calls. // Usually only for JTA: Spring synchronization might get activated here // in case of a pre-existing JTA transaction. boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, null); // 不支持备份点的情况下会新建事务 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; &#125; &#125; // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED. if (debugEnabled) &#123; logger.debug(&quot;Participating in existing transaction&quot;); &#125; if (isValidateExistingTransaction()) &#123; if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123; Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel(); if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123; Constants isoConstants = DefaultTransactionDefinition.constants; throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; + definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; + (currentIsolationLevel != null ? isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) : &quot;(unknown)&quot;)); &#125; &#125; if (!definition.isReadOnly()) &#123; if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123; throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; + definition + &quot;] is not marked as read-only but existing transaction is&quot;); &#125; &#125; &#125; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);&#125; 一些干货aop注入的实现过程doCreateBean中会暴露一个bean引用，用以处理循环引用；同时大家熟知的AOP就是通过getEarlyBeanReference(..)方法植入的；具体的，是在wrapIfNecessary(..) 方法中封装了advice并创建了代理； @Autowired注解的实现 doCreateBean(..)中的populateBean(..)方法，实现了基于@Autowired注解的实现，根据名称或类型进行依赖的注入；]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Mvc源码阅读]]></title>
    <url>%2F2018%2F10%2F19%2Fspringmvc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Spring Mvc源码阅读 12345678910111213SpringMVC核心处理流程：1、DispatcherServlet前端控制器接收发过来的请求，交给HandlerMapping处理器映射器2、HandlerMapping处理器映射器，根据请求路径找到相应的HandlerAdapter处理器适配器（处理器适配器就是那些拦截器或Controller）3、HandlerAdapter处理器适配器，请求数据绑定和转换，处理一些功能请求，返回一个ModelAndView对象（包括模型数据、逻辑视图名）4、ViewResolver视图解析器，先根据ModelAndView中设置的View解析具体视图5、然后再将Model模型中的数据渲染到View上这些过程都是以DispatcherServlet为中轴线进行的。 入口源码springMVC的请求会交由dispatcherServlet处理，其本质上是一个多线程的请求处理机制；核心业务逻辑被设计在doDispatcher(..)方法中；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet&apos;s HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet&apos;s installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It&apos;s up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 绑定url -&gt; 具体的handler/Controller.method(..) // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 根据handler绑定具体的adapter // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // interceptor 拦截器进行前置预处理 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 在handle方法中进行了请求数据的绑定，方法invoke，返回model的处理和封装等 // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&apos;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 核心关注的几个问题请求如何路由到具体的Controller上的方法进行处理?根据请求路径，与已知的handlerMapping进行匹配，并加入interceptors: dispatcherServlet.getHandler()最终调用AbstracteHandlerMapping.getHandlerExecutionChain(..)中进行url与handlerMapping进行匹配，并加入interceptors; 扁平化的前端请求数据如何进行数据绑定？我们知道，前端的get/post等请求，会被requestServlet接受，并封装成HttpServletRequest的parameterMap中，每一项请求的数据结构都是 K-V 形的。 而我们知道，像这样的形式， 那么在这个中间数据如何实现数据绑定到Bean，String格式的Value 转换成各种目标格式。 事实上，spring MVC将整个网络请求的处理流程进行了合理的切分,其大致的处理流程如下：12345678910111.调用匹配到的adapter.handle(..)2.然后调用invokeAndHandle(..)3.调用invokeForRequest(..)获取getMethodArgumentValues(..)获取和绑定入参;4.在具体的方法中，获取支持处理的argumentResolvers,然后调用resolveArgument(..)方法;5.在ModelAttributeMethodProcessor中调用bindRequestParameters(binder, webRequest),方法，然后再调用bind()进行bean参数的绑定；6.调用binder.convertIfNecessary(arg, parameter.getParameterType(), parameter)方法进行参数的转换；]]></content>
      <tags>
        <tag>Spring MVC</tag>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
</search>
