<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hive使用攻略]]></title>
    <url>%2F2019%2F03%2F01%2Fhive%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[本文着重收纳hive日常使用中的坑点和难点。]]></content>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spark学习笔记]]></title>
    <url>%2F2019%2F02%2F22%2Fspark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[万事开头难，本文着重记录spark学习过程中的一些重要的环节和内容。Spark架构Spark作用Spark架构Spark框架的常用api]]></content>
      <tags>
        <tag>spark</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java架构师技能图谱]]></title>
    <url>%2F2019%2F01%2F04%2FJava%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[《后端架构师技术图谱》数据结构队列《java队列——queue详细分析》非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》集合《Java Set集合的详解》链表、数组《Java集合详解–什么是List》字典、关联数组《Java map 详解 - 用法、遍历、排序、常用API等》栈《java数据结构与算法之栈（Stack）设计与实现》《Java Stack 类》《java stack的详细实现分析》Stack 是线程安全的。内部使用数组保存数据，不够时翻倍。树二叉树每个节点最多有两个叶子节点。《二叉树》完全二叉树《完全二叉树》叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。《浅谈数据结构-平衡二叉树》《浅谈算法和数据结构: 八 平衡查找树之2-3树》二叉查找树（BST）二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。《浅谈算法和数据结构: 七 二叉查找树》红黑树《最容易懂得红黑树》添加阶段后，左旋或者右旋从而再次达到平衡。《浅谈算法和数据结构: 九 平衡查找树之红黑树》B，B+，B*树MySQL是基于B+树聚集索引组织表《B-树，B+树，B*树详解》《B-树，B+树与B*树的优缺点比较》B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。LSM 树LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。《LSM树 VS B+树》B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。《LSM树（Log-Structured Merge Tree）存储引擎》极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。BitSet经常用于大规模数据的排重检查。《Java Bitset类》《Java BitSet（位集）》常用算法《常见排序算法及对应的时间复杂度和空间复杂度》排序、查找算法《常见排序算法及对应的时间复杂度和空间复杂度》选择排序《Java中的经典算法之选择排序（SelectionSort）》每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。冒泡排序《冒泡排序的2种写法》相邻元素前后交换、把最大的排到最后。时间复杂度 O(n²)插入排序《排序算法总结之插入排序》快速排序《坐在马桶上看算法：快速排序》一侧比另外一次都大或小。归并排序《图解排序算法(四)之归并排序》分而治之，分成小份排序，在合并(重建一个新空间进行复制)。希尔排序TODO堆排序《图解排序算法(三)之堆排序》排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。计数排序《计数排序和桶排序》和桶排序过程比较像，差别在于桶的数量。桶排序《【啊哈！算法】最快最简单的排序——桶排序》《排序算法（三）：计数排序与桶排序》桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。每个桶单独进行排序，然后再遍历每个桶。基数排序按照个位、十位、百位、…依次来排。《排序算法系列：基数排序》《基数排序》二分查找《二分查找(java实现)》要求待查找的序列有序。时间复杂度 O(logN)。《java实现二分查找-两种方式》while + 递归。Java 中的排序工具《Arrays.sort和Collections.sort实现原理解析》Collections.sort算法调用的是合并排序。Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。布隆过滤器常用于大数据的排重，比如email，url 等。核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。优点：空间和时间效率都很高。缺点：随着存入的元素数量增加，误算率随之增加。《布隆过滤器 – 空间效率很高的数据结构》《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》《基于Redis的布隆过滤器的实现》基于 Redis 的 Bitmap 数据结构。《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》使用Java中的 BitSet 类 和 加权和hash算法。字符串比较KMP 算法KMP：Knuth-Morris-Pratt算法（简称KMP）核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。《字符串匹配的KMP算法》深度优先、广度优先《广度优先搜索BFS和深度优先搜索DFS》贪心算法《算法：贪婪算法基础》《常见算法及问题场景——贪心算法》回溯算法《 五大常用算法之四：回溯法》剪枝算法《α-β剪枝算法》动态规划《详解动态规划——邹博讲动态规划》《动态规划算法的个人理解》朴素贝叶斯《带你搞懂朴素贝叶斯分类算法》P(B|A)=P(A|B)P(B)/P(A)《贝叶斯推断及其互联网应用1》《贝叶斯推断及其互联网应用2》推荐算法《推荐算法综述》《TOP 10 开源的推荐系统简介》最小生成树算法《算法导论–最小生成树（Kruskal和Prim算法）》最短路径算法《Dijkstra算法详解》并发Java 并发Java 并发知识合集JAVA并发知识图谱多线程《40个Java多线程问题总结》线程安全《Java并发编程——线程安全及解决机制简介》一致性、事务事务 ACID 特性《数据库事务ACID特性》事务的隔离级别未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。序列化：所有事物串行处理（牺牲了效率）《理解事务的4种隔离级别》数据库事务的四大特性及事务隔离级别《MySQL的InnoDB的幻读问题 》幻读的例子非常清楚。通过 SELECT … FOR UPDATE 解决。《一篇文章带你读懂MySQL和InnoDB》图解脏读、不可重复读、幻读问题。MVCC《【mysql】关于innodb中MVCC的一些理解》innodb 中 MVCC 用在 Repeatable-Read 隔离级别。MVCC 会产生幻读问题（更新时异常。）《轻松理解MYSQL MVCC 实现机制》通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间每次只操作比当前版本小（或等于）的 行。锁Java中的锁和同步类《Java中的锁分类》主要包括 synchronized、ReentrantLock、和 ReadWriteLock。《Java并发之AQS详解》《Java中信号量 Semaphore》有数量控制申请用 acquire，申请不要则阻塞；释放用 release。《java开发中的Mutex vs Semaphore》简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。公平锁 &amp; 非公平锁公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。《公平锁与非公平锁》默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。悲观锁悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。《【MySQL】悲观锁&amp;乐观锁》乐观锁的方式：版本号+重试方式悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。《Mysql查询语句使用select.. for update导致的数据库死锁分析》mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。锁相同数据的不同索引条件可能会引起死锁。《Mysql并发时经典常见的死锁原因及解决方法》乐观锁 &amp; CAS《乐观锁的一种实现方式——CAS》和MySQL乐观锁方式相似，只不过是通过和原值进行比较。ABA 问题由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。《Java CAS 和ABA问题》《Java 中 ABA问题及避免》AtomicStampedReference 和 AtomicStampedReference。CopyOnWrite容器可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。《JAVA中写时复制(Copy-On-Write)Map实现》实现读写分离，读取发生在原始数据上，写入发生在副本上。不用加锁，通过最终一致实现一致性。《聊聊并发-Java中的Copy-On-Write容器》RingBuffer《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》可重入锁 &amp; 不可重入锁《可重入锁和不可重入锁》通过简单代码举例说明可重入锁和不可重入锁。可重入锁指同一个线程可以再次获得之前已经获得的锁。可重入锁可以用户避免死锁。Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock《ReenTrantLock可重入锁（和synchronized的区别）总结》synchronized 使用方便，编译器来加锁，是非公平锁。ReenTrantLock 使用灵活，锁的公平性可以定制。相同加锁场景下，推荐使用 synchronized。互斥锁 &amp; 共享锁互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。《ReadWriteLock场景应用》死锁《“死锁”四个必要条件的合理解释》互斥、持有、不可剥夺、环形等待。Java如何查看死锁？JConsole 可以识别死锁。java多线程系列：死锁及检测jstack 可以显示死锁。操作系统计算机原理《操作系统基础知识——操作系统的原理，类型和结构》CPU多级缓存典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。《从Java视角理解CPU缓存和伪共享》进程TODO线程《线程的生命周期及状态转换详解》协程《终结python协程—-从yield到actor模型的实现》线程的调度是由操作系统负责，协程调度是程序自行负责与线程相比，协程减少了无谓的操作系统切换.实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.Linux《Linux 命令大全》设计模式设计模式的六大原则《设计模式的六大原则》开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。合成复用原则：尽量使用合成/聚合,而不是使用继承。23种常见设计模式《设计模式》《23种设计模式全解析》《设计模式类图与示例》应用场景《细数JDK里的设计模式》结构型模式：适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy创建模式:抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。行为模式：责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。空对象模式：如 java.util.Collections#emptyList()。观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。《Spring-涉及到的设计模式汇总》《Mybatis使用的设计模式》单例模式《单例模式的三种实现 以及各自的优缺点》《单例模式－－反射－－防止序列化破坏单例模式》使用枚举类型。责任链模式TODOMVC《MVC 模式》模型(model)－视图(view)－控制器(controller)IOC《理解 IOC》《IOC 的理解与解释》正向控制：传统通过new的方式。反向控制，通过容器注入对象。作用：用于模块解耦。DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。AOP《轻松理解AOP(面向切面编程)》《Spring AOP详解》《Spring AOP的实现原理》Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。《Spring AOP 实现原理与 CGLIB 应用》Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类UML《UML教程》微服务思想《微服务架构设计》《微服务架构技术栈选型手册》康威定律《微服务架构的理论基础 - 康威定律》定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。《微服务架构核⼼20讲》运维 &amp; 统计 &amp; 技术支持常规监控《腾讯业务系统监控的修炼之路》监控的方式：主动、被动、旁路(比如舆情监控)监控类型： 基础监控、服务端监控、客户端监控、监控、用户端监控监控的目标：全、块、准核心指标：请求量、成功率、耗时《开源还是商用？十大云运维监控工具横评》Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。《监控报警系统搭建及二次开发经验》命令行监控工具《常用命令行监控工具》top、sar、tsar、nload《20个命令行工具监控 Linux 系统性能》《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》APMAPM — Application Performance Management《Dapper，大规模分布式系统的跟踪系统》CNCF OpenTracing，中文版主要开源软件，按字母排序Apache SkyWalkingCATCNCF jaegerPinpointZipkin《开源APM技术选型与实战》主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。统计分析《流量统计的基础：埋点》常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度《APP埋点常用的统计工具、埋点目标和埋点内容》第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。《美团点评前端无痕埋点实践》所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。持续集成(CI/CD)《持续集成是什么？》《8个流行的持续集成工具》Jenkins《使用Jenkins进行持续集成》环境分离开发、测试、生成环境分离。《开发环境、生产环境、测试环境的基本理解和区》自动化运维Ansible《Ansible中文权威指南》《Ansible基础配置和企业级项目实用案例》puppet《自动化运维工具——puppet详解》chef《Chef 的安装与使用》测试TDD 理论《深度解读 - TDD（测试驱动开发）》基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈；单元测试《Java单元测试之JUnit篇》《JUnit 4 与 TestNG 对比》TestNG 覆盖 JUnit 功能，适用于更复杂的场景。《单元测试主要的测试功能点》模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。压力测试《Apache ab 测试使用指南》《大型网站压力测试及优化方案》《10大主流压力/负载/性能测试工具推荐》《真实流量压测工具 tcpcopy应用浅析》《nGrinder 简易使用教程》全链路压测《京东618：升级全链路压测方案，打造军演机器人ForceBot》《饿了么全链路压测的探索与实践》《四大语言，八大框架｜滴滴全链路压测解决之道》《全链路压测经验》A/B 、灰度、蓝绿测试《技术干货 | AB 测试和灰度发布探索及实践》《nginx 根据IP 进行灰度发布》《蓝绿部署、A/B 测试以及灰度发布》虚拟化《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》KVM《KVM详解，太详细太深入了，经典》《【图文】KVM 虚拟机安装详解》Xen《Xen虚拟化基本原理详解》OpenVZ《开源Linux容器 OpenVZ 快速上手指南》容器技术Docker《几张图帮你理解 docker 基本原理及快速入门》《Docker 核心技术与实现原理》《Docker 教程》云技术OpenStack《OpenStack构架知识梳理》DevOps《一分钟告诉你究竟DevOps是什么鬼？》《DevOps详解》文档管理Confluence-收费文档管理系统GitLab?Wiki中间件Web ServerNginx《Ngnix的基本学习-多进程和Apache的比较》Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。《nginx与Apache的对比以及优缺点》nginx只适合静态和反向代理，不适合处理动态请求。OpenResty官方网站《浅谈 OpenResty》通过 Lua 模块可以在Nginx上进行开发。agentzh 的 Nginx 教程Tengine官方网站Apache Httpd官方网站Tomcat架构原理《TOMCAT原理详解及请求过程》《Tomcat服务器原理详解》《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》《四张图带你了解Tomcat系统架构》《JBoss vs. Tomcat: Choosing A Java Application Server》Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。Jboss 实现全部了JEE特性，软件开源免费、文档收费。调优方案《Tomcat 调优方案》启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）；《tomcat http协议与ajp协议》《AJP与HTTP比较和分析》AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。并发高时，AJP协议优于HTTP协议。Jetty《Jetty 的工作原理以及与 Tomcat 的比较》《jetty和tomcat优势比较》架构比较:Jetty的架构比Tomcat的更为简单。性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。缓存《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》本地缓存《HashMap本地缓存》《EhCache本地缓存》堆内、堆外、磁盘三级缓存。可按照缓存空间容量进行设置。按照时间、次数等过期策略。《Guava Cache》简单轻量、无堆外、磁盘缓存。《Nginx本地缓存》《Pagespeed—懒人工具，服务器端加速》客户端缓存《浏览器端缓存》主要是利用 Cache-Control 参数。《H5 和移动端 WebView 缓存机制解析与实战》服务端缓存Web缓存nuster - nuster cachevarnish - varnish cachesquid - squid cacheMemcached《Memcached 教程》《深入理解Memcached原理》采用多路复用技术提高并发性。slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。《Memcached软件工作原理》《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》《memcache 中 add 、 set 、replace 的区别》区别在于当key存在还是不存在时，返回值是true和false的。《memcached全面剖析》Redis《Redis 教程》《redis底层原理》使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。《Redis持久化方式》RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。也可以两者结合使用。《分布式缓存–序列3–原子操作与CAS乐观锁》架构《Redis单线程架构》回收策略《redis的回收策略》Tair官方网站《Tair和Redis的对比》特点：可以配置备份节点数目，通过异步同步到备份节点一致性Hash算法。架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。几种存储引擎:MDB，完全内存性，可以用来存储Session等数据。Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。消息队列《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》RabbitMQ 消费者默认是推模式（也支持拉模式）。Kafka 默认是拉模式。Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》消息总线消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。《消息总线VS消息队列》消息的顺序《如何保证消费者接收消息的顺序》RabbitMQ支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。《RabbitMQ的应用场景以及基本原理介绍》《消息队列之 RabbitMQ》《RabbitMQ之消息确认机制（事务+Confirm）》RocketMQJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。《RocketMQ 实战之快速入门》《RocketMQ 源码解析》ActiveMQ纯Java实现，兼容JMS，可以内嵌于Java应用中。《ActiveMQ消息队列介绍》Kafka高吞吐量、采用拉模式。适合高IO场景，比如日志同步。官方网站《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》《Kafka分区机制介绍与示例》Redis 消息推送生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。《Redis学习笔记之十：Redis用作消息队列》ZeroMQTODO定时调度单机定时调度《linux定时任务cron配置》《Linux cron运行原理》fork 进程 + sleep 轮询《Quartz使用总结》《Quartz源码解析 —- 触发器按时启动原理》《quartz原理揭秘和源码解读》定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。分布式定时调度《这些优秀的国产分布式任务调度系统，你用过几个？》opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares《Quartz任务调度的基本实现原理》Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的《Elastic-Job-Lite 源码解析》《Elastic-Job-Cloud 源码解析》RPC《从零开始实现RPC框架 - RPC原理及实现》核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》Dubbo官方网站dubbo实现原理简单介绍SPITODOThrift官方网站《Thrift RPC详解》支持多语言，通过中间语言定义接口。gRPC服务端可以认证加密，在外网环境下，可以保证数据安全。官方网站《你应该知道的RPC原理》数据库中间件Sharding Jdbc官网源码解析日志系统日志搜集《从零开始搭建一个ELKB日志收集系统》《用ELK搭建简单的日志收集分析系统》《日志收集系统-探究》配置中心Apollo - 携程开源的配置中心应用Spring Boot 和 Spring Cloud支持推、拉模式更新配置支持多种语言《基于zookeeper实现统一配置管理》《 Spring Cloud Config 分布式配置中心使用教程》servlet 3.0 异步特性可用于配置中心的客户端《servlet3.0 新特性——异步处理》API 网关主要职责：请求转发、安全认证、协议转换、容灾。《API网关那些儿》《谈API网关的背景、架构以及落地方案》《使用Zuul构建API Gateway》《Spring Cloud Gateway 源码解析》《HTTP API网关选择之一Kong介绍》网络协议OSI 七层协议《OSI七层协议模型、TCP/IP四层模型学习笔记》TCP/IP《深入浅出 TCP/IP 协议》《TCP协议中的三次握手和四次挥手》HTTP《http协议详解(超详细)》HTTP2.0《HTTP 2.0 原理详细分析》《HTTP2.0的基本单位为二进制帧》利用二进制帧负责传输。多路复用。HTTPS《https原理通俗了解》使用非对称加密协商加密算法使用对称加密方式传输数据使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。《八大免费SSL证书-给你的网站免费添加Https安全加密》网络模型《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。《select、poll、epoll之间的区别总结》select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。《select，poll，epoll比较 》在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。《深入理解Java NIO》NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务《BIO与NIO、AIO的区别》《两种高效的服务器设计模型：Reactor和Proactor模型》Epoll《epoll使用详解（精髓）》Java NIO《深入理解Java NIO》《Java NIO编写Socket服务器的一个例子》kqueue《kqueue用法简介》连接和短连接《TCP/IP系列——长连接与短连接的区别》框架《Netty原理剖析》Reactor 模式介绍。Netty 是 Reactor 模式的一种实现。零拷贝（Zero-copy）《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。序列化(二进制协议)Hessian《Hessian原理分析》Binary-RPC;不仅仅是序列化Protobuf《Protobuf协议的Java应用例子》Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。《Protocol Buffers序列化协议及应用》* 关于协议的解释；缺点：可读性差; 《简单的使用 protobuf 和 protostuff》protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。数据库基础理论数据库设计的三大范式《数据库的三大范式以及五大约束》第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；MySQL原理《MySQL的InnoDB索引原理详解》《MySQL存储引擎－－MyISAM与InnoDB区别》两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁《myisam和innodb索引实现的不同》InnoDB《一篇文章带你读懂Mysql和InnoDB》优化《MySQL36条军规》《MYSQL性能优化的最佳20+条经验》《SQL优化之道》《mysql数据库死锁的产生原因及解决办法》《导致索引失效的可能情况》《 MYSQL分页limit速度太慢优化方法》原则上就是缩小扫描范围。索引聚集索引, 非聚集索引《MySQL 聚集索引/非聚集索引简述》《MyISAM和InnoDB的索引实现》MyISAM 是非聚集，InnoDB 是聚集复合索引《复合索引的优点和注意事项》文中有一处错误：对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。《MySQL查询where条件的顺序对查询效率的影响》自适应哈希索引(AHI)《InnoDB存储引擎——自适应哈希索引》explain《MySQL 性能优化神器 Explain 使用分析》NoSQLMongoDBMongoDB 教程《Mongodb相对于关系型数据库的优缺点》优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；Hbase《简明 HBase 入门教程（开篇）》《深入学习HBase架构原理》《传统的行存储和（HBase）列存储的区别》《Hbase与传统数据库的区别》空数据不存储，节省空间，且适用于并发。《HBase Rowkey设计》rowkey 按照字典顺序排列，便于批量扫描。通过散列可以避免热点。搜索引擎搜索引擎原理《倒排索引–搜索引擎入门》Lucene《Lucene入门简介》Elasticsearch《Elasticsearch学习，请先看这一篇！》《Elasticsearch索引原理》Solr《 Apache Solr入门教程》《elasticsearch与solr比较》sphinx《Sphinx 的介绍和原理探索》性能性能优化方法论《15天的性能优化工作，5方面的调优经验》代码层面、业务层面、数据库层面、服务器层面、前端优化。《系统性能优化的几个方面》容量评估《联网性能与容量评估的方法论和典型案例》《互联网架构，如何进行容量设计？》评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPSCDN 网络《CDN加速原理》《国内有哪些比较好的 CDN？》连接池《主流Java数据库连接池比较与开发配置实战》性能调优《九大Java性能调试工具，必备至少一款》大数据流式计算Storm官方网站《最详细的Storm入门教程》Flink《Flink之一 Flink基本原理介绍》Kafka Stream《Kafka Stream调研：一种轻量级流计算模式》应用场景例如：广告相关实时统计；推荐系统用户画像标签实时更新；线上服务健康状况实时监测；实时榜单；实时数据统计。Hadoop《用通俗易懂的话说下hadoop是什么,能做什么》《史上最详细的Hadoop环境搭建》HDFS《【Hadoop学习】HDFS基本原理》MapReduce《用通俗易懂的大白话讲解Map/Reduce原理》《 简单的map-reduce的java例子》Yarn《初步掌握Yarn的架构及原理》Spark《Spark(一): 基本架构及原理》安全web 安全XSS《xss攻击原理与解决方法》CSRF《CSRF原理及防范》SQL 注入《SQL注入》Hash Dos《邪恶的JAVA HASH DOS攻击》利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。《一种高级的DoS攻击-Hash碰撞攻击》《关于Hash Collision DoS漏洞：解析与解决方案》脚本注入《上传文件漏洞原理及防范》漏洞扫描工具《DVWA》W3afOpenVAS详解验证码《验证码原理分析及实现》《详解滑动验证码的实现原理》滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。《淘宝滑动验证码研究》DDoS 防范《学习手册：DDoS的攻击方式及防御手段》《免费DDoS攻击测试工具大合集》用户隐私信息保护用户密码非明文保存，加动态salt。身份证号，手机号如果要显示，用 “*” 替代部分字符。联系方式在的显示与否由用户自己控制。TODO《个人隐私包括哪些》《在互联网上，隐私的范围包括哪些？》《用户密码保存》序列化漏洞《Lib之过？Java反序列化漏洞通用利用分析》加密解密对称加密《常见对称加密算法》DES、3DES、Blowfish、AESDES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。哈希算法《常用的哈希算法》MD5 和 SHA-1 已经不再安全，已被弃用。目前 SHA-256 是比较安全的。《基于Hash摘要签名的公网URL签名验证设计方案》非对称加密《常见非对称加密算法》RSA、DSA、ECDSA(螺旋曲线加密算法)和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。256位的ECC秘钥的安全性等同于3072位的RSA秘钥。《区块链的加密技术》服务器安全《Linux强化论：15步打造一个安全的Linux服务器》数据安全数据备份TODO网络隔离内外网分离TODO登录跳板机在内外环境中通过跳板机登录到线上主机。《搭建简易堡垒机》授权、认证RBAC《基于组织角色的权限设计》《权限系统与RBAC模型概述》《Spring整合Shiro做权限控制模块详细案例分析》OAuth2.0《理解OAuth 2.0》《一张图搞定OAuth2.0》双因素认证（2FA）2FA - Two-factor authentication，用于加强登录验证常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)单点登录(SSO)《单点登录原理与简单实现》CAS单点登录框架常用开源框架开源协议《开源协议的选择》如何选择一个开源软件协议日志框架Log4j、Log4j2《log4j 详细讲解》《log4j2 实际使用详解》《Log4j1,Logback以及Log4j2性能测试对比》Log4J 异步日志性能优异。Logback《最全LogBack 详解、含java案例和配置说明》ORM《ORM框架使用优缺点》主要目的是为了提高开发效率。MyBatis：《mybatis缓存机制详解》一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。《MyBatis学习之代码生成器Generator》网络框架TODOWeb 框架Spring 家族SpringSpring 简明教程Spring Boot官方网站《Spring Boot基础教程》Spring CloudSpring Boot 中文索引站Spring Cloud 中文文档《Spring Cloud基础教程》工具框架《Apache Commons 工具类介绍及简单使用》《Google guava 中文教程》分布式设计扩展性设计《架构师不可不知的十大可扩展架构》总结下来，通用的套路就是分布、缓存及异步处理。《可扩展性设计之数据切分》水平切分+垂直切分利用中间件进行分片如，MySQL Proxy。利用分片策略进行切分，如按照ID取模。《说说如何实现可扩展性的大型网站架构》分布式服务+消息队列。《大型网站技术架构（七）–网站的可扩展性架构》稳定性 &amp; 高可用《系统设计：关于高可用系统的一些技术方案》可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。自动化测试：通过完善的测试，减少发布引起的故障。灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。《关于高可用的系统》设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。硬件负载均衡《转！！负载均衡器技术Nginx和F5的优缺点对比》主要是和F5对比。《软/硬件负载均衡产品 你知多少？》软件负载均衡《几种负载均衡算法》轮寻、权重、负载、最少连接、QoS《DNS负载均衡》配置简单，更新速度慢。《Nginx负载均衡》简单轻量、学习成本低；主要适用于web应用。《借助LVS+Keepalived实现负载均衡 》配置比较负载、只支持到4层，性能较高。《HAProxy用法详解 全网最详细中文文档》支持到七层（比如HTTP）、功能比较全面，性能也不错。《Haproxy+Keepalived+MySQL实现读均衡负载》主要是用户读请求的负载均衡。《rabbitmq+haproxy+keepalived实现高可用集群搭建》限流《谈谈高并发系统的限流》计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。Nginx 限流：通过 limit_req 等模块限制并发连接数。应用层容灾《防雪崩利器：熔断器 Hystrix 的原理与使用》雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。Hystrix设计原则：资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。《缓存穿透，缓存击穿，缓存雪崩解决方案分析》《缓存击穿、失效以及热点key问题》主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；热点数据：热点数据单独存储；使用本地缓存；分成多个子key；跨机房容灾《“异地多活”多机房部署经验谈》通过自研中间件进行数据同步。《异地多活（异地双活）实践经验》注意延迟问题，多次跨机房调用会将延时放大数倍。建房间专线很大概率会出现问题，做好运维和程序层面的容错。不能依赖于程序端数据双写，要有自动同步方案。数据永不在高延迟和较差网络质量下，考虑同步质量问题。核心业务和次要业务分而治之，甚至只考虑核心业务。异地多活监控部署、测试也要跟上。业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。控制跨机房消息体大小，越小越好。考虑使用docker容器虚拟化技术，提高动态调度能力。容灾技术及建设经验介绍容灾演练流程《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》常见故障画像案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。平滑启动平滑重启应用思路1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用《JVM安全退出（如何优雅的关闭java服务）》推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。《常见Java应用如何优雅关闭》Java、Spring、Dubbo 优雅关闭方式。数据库扩展读写分离模式《Mysql主从方案的实现》《搭建MySQL主从复制经典架构》《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》《DRBD+Heartbeat+Mysql高可用读写分离架构》DRDB 进行磁盘复制，避免单点问题。《MySQL Cluster 方式》分片模式《分库分表需要考虑的问题及方案》中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。问题：事务、Join、迁移、扩容、ID、分页等。事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。分库策略：数值范围；取模；日期等。分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。《MySql分表和表分区详解》分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。分表：物理上创建不同的表、客户端需要管理分表路由。服务治理服务注册与发现《永不失联！如何实现微服务架构中的服务发现？》客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。服务器端服务发现模式：客户端通过负载均衡查询服务实例。《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）作者认为目前 Consul 对 Spring cloud 的支持比较好。《基于Zookeeper的服务注册与发现》优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。服务路由控制《分布式服务框架学习笔记4 服务路由》原则：透明化路由负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。配置方式：统一注册表；本地配置；动态下发。分布式一致CAP 与 BASE 理论《从分布式一致性谈到CAP理论、BASE理论》一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)CAP：一致性、可用性、分区容错性(网络故障引起)BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。分布式锁《分布式锁的几种实现方式》基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。《基于Zookeeper的分布式锁》清楚的原理描述 + Java 代码示例。《jedisLock—redis分布式锁实现》基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。《Memcached 和 Redis 分布式锁方案》利用 memcached 的 add（有别于set）操作，当key存在时，返回false。分布式一致性算法PAXOS《分布式系列文章——Paxos算法原理与推导》《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》《【分布式】Zookeeper与Paxos》Zab《Zab：Zookeeper 中的分布式一致性协议介绍》Raft《Raft 为什么是更易理解的分布式一致性算法》三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）通过随机等待的方式发出投票，得票多的获胜。Gossip《Gossip算法》两阶段提交、多阶段提交《关于分布式事务、两阶段提交协议、三阶提交协议》幂等《分布式系统—幂等性设计》幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。分布式一致方案《分布式系统事务一致性解决方案》《保证分布式系统数据一致性的6种方案》分布式 Leader 节点选举《利用zookeeper实现分布式leader节点选举》TCC(Try/Confirm/Cancel) 柔性事务《传统事务与柔性事务》基于BASE理论：基本可用、柔性状态、最终一致。解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。分布式文件系统说说分布式文件存储系统-基本架构 ？《各种分布式文件系统的比较》 ？HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。FastDFS：轻量级、适合小文件。唯一ID 生成全局唯一ID《高并发分布式系统中生成全局唯一Id汇总》Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();”UUID：缺点，无序，字符串过长，占用空间，影响检索性能。MongoDB 方案：利用 ObjectId。缺点：不能自增。《TDDL 在分布式下的SEQUENCE原理》在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。一致性Hash算法《一致性哈希算法》设计思想 &amp; 开发模式DDD(Domain-driven Design - 领域驱动设计)《浅谈我对DDD领域驱动设计的理解》概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。《领域驱动设计的基础知识总结》领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；领域通用语言：领域专家、开发设计人员都能立即的语言或工具。经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。使用的模式：关联尽量少，尽量单项，尽量降低整体复杂度。实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；工厂（Factory）：类似于设计模式中的工厂模式。仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。《领域驱动设计(DDD)实现之路》聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》命令查询职责分离(CQRS)CQRS — Command Query Responsibility Seperation《领域驱动设计系列 (六)：CQRS》核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。《DDD CQRS架构和传统架构的优缺点比较》最终一致的设计理念；依赖于高可用消息中间件。《CQRS架构简介》一个实现 CQRS 的抽象案例。《深度长文：我对CQRS/EventSourcing架构的思考》CQRS 模式分析 + 12306 抢票案例贫血，充血模型《贫血，充血模型的解释以及一些经验》失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。作者主张使用贫血模式。Actor 模式TODO响应式编程ReactorTODORxJavaTODOVert.xTODODODAF2.0《DODAF2.0方法论》《DODAF2.0之能力视角如何落地》Serverless无需过多关系服务器的服务架构理念。《什么是Serverless无服务器架构？》Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。Serverless 不代表某个具体的框架。《如何理解Serverless？》依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）Service Mesh《什么是Service Mesh？》《初识 Service Mesh》项目管理架构评审《架构设计之如何评审架构设计说明书》《人人都是架构师：非功能性需求》重构《架构之重构的12条军规》代码规范《阿里巴巴Java开发手册》代码 Review制度还是制度!另外，每个公司需要根据自己的需求和目标制定自己的 check list《为什么你做不好 Code Review？》代码 review 做的好，在于制度建设。《从零开始Code Review》《Code Review Checklist》《Java Code Review Checklist》《如何用 gitlab 做 code review》RUP《运用RUP 4+1视图方法进行软件架构设计》看板管理《说说看板在项目中的应用》SCRUMSCRUM - 争球3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；五个价值观：专注、勇气、公开、承诺、尊重。《敏捷项目管理流程-Scrum框架最全总结！》《敏捷其实很简单3—敏捷方法之scrum》敏捷开发TODO极限编程（XP）XP - eXtreme Programming《主流敏捷开发方法：极限编程XP》是一种指导开发人员的方法论。4大价值：沟通：鼓励口头沟通，提高效率。简单：够用就好。反馈：及时反馈、通知相关人。勇气：提倡拥抱变化，敢于重构。5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。结对编程边写码，边review。能够增强代码质量、减少bug。《结对编程》PDCA 循环质量管理P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进《PDCA》FMEA管理模式TODO通用业务术语TODO技术趋势TODO政策、法规TODO法律严格遵守刑法253法条我国刑法第253条之一规定：国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”《非法获取公民个人信息罪》架构师素质《架构师画像》业务理解和抽象能力NB的代码能力全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面；全局：是否考虑到了对上下游的系统的影响。权衡：权衡投入产出比；优先级和节奏控制；《关于架构优化和设计，架构师必须知道的事情》要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。基础设施、配置、测试、开发、运维综合考虑。考虑人、团队、和组织的影响。《如何才能真正的提高自己，成为一名出色的架构师？》《架构师的必备素质和成长途径》素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。《架构设计师—你在哪层楼？》第一层的架构师看到的只是产品本身第二层的架构师不仅看到自己的产品，还看到了整体的方案第三层的架构师看到的是商业价值团队管理TODO招聘资讯行业资讯36krTechweb公众号列表TODO博客团队博客阿里中间件博客美团点评技术团队博客个人博客阮一峰的网络日志酷壳 - COOLSHELL-陈皓hellojava-阿里毕玄Cm’s Blog程序猿DD-翟永超-《Spring Cloud微服务实战》作者综合门户、社区国内：CSDN老牌技术社区、不必解释。51cto.comITeye偏 Java 方向博客园ChinaUnix偏 Linux 方向开源中国社区深度开源伯乐在线涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。ITPUB腾讯云— 云+社区阿里云— 云栖社区IBM DeveloperWorks开发者头条LinkedKeeper国外：DZoneReddit问答、讨论类社区segmentfault问答+专栏知乎stackoverflow行业数据分析艾瑞网QUEST MOBILE国家数据TalkingData专项网站测试:领测国际测试窝TesterHome运维:* [运维派](http://www.yunweipai.com/) * [Abcdocker](https://www.abcdocker.com/) Java:ImportNew专注于 Java 技术分享HowToDoInJava英文博客安全红黑联盟FreeBuf大数据中国大数据其他专题网站：InfoQ偏重于基础架构、运维方向DockerInfo专注于 Docker 应用及咨询、教程的网站Linux公社Linux 主题社区其他类程序员技能图谱推荐参考书在线电子书《深入理解Spring Cloud与微服务构建》《阿里技术参考图册-研发篇》《阿里技术参考图册-算法篇》《2018美团点评技术年货（合辑）》70MInfoQ《架构师》月刊《架构师之路》纸质书开发方面《阿里巴巴Java开发手册》详情架构方面《软件架构师的12项修炼：技术技能篇》详情《架构之美》详情《分布式服务架构》详情《聊聊架构》 详情《云原生应用架构实践》详情《亿级流量网站架构核心技术》详情《淘宝技术这十年》详情《企业IT架构转型之道-中台战略思想与架构实战》 详情《高可用架构（第1卷）》详情技术管理方面《CTO说》详情《技术管理之巅》详情《网易一千零一夜：互联网产品项目管理实战》详情基础理论《数学之美》详情《编程珠玑》详情工具方面TODO大数据方面技术资源开源资源githubApache 软件基金会手册、文档、教程国内：W3CschoolRunoob.comHTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。Love2.io很多很多中文在线电子书，是一个全新的开源技术文档分享平台。gitbook.cn付费电子书。ApacheCNAI、大数据方面系列中文文档。国外：Quick Code免费在线技术教程。gitbook.com有部分中文电子书。CheatographyCheat Sheets 大全，单页文档网站。Tutorialspoint知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。在线课堂学徒无忧极客时间segmentfault斯达克学院牛客网极客学院51CTO学院会议、活动QConArchSummitGITC全球互联网技术大会活动发布平台:活动行常用APP极客时间得到找工作Boss直聘拉勾网猎聘100Offer工具极客搜索技术文章搜索引擎。代码托管Coding码云文件服务七牛又拍云综合云服务商阿里云腾讯云百度云新浪云金山云亚马逊云(AWS)谷歌云微软云VPSLinodeDigitalOceanVultr]]></content>
      <tags>
        <tag>架构师</tag>
        <tag>Java</tag>
        <tag>技能图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skr dubbo源码]]></title>
    <url>%2F2018%2F12%2F10%2Fskr-dubbo%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[死磕skr的dubbo，它凭什么这么多人在用？dubbo整体架构图调用流程事件处理魔鬼在细节一致性哈希算法实现原理：讲实际节点*n倍，构成一个由虚拟节点的哈希环，然后key的哈希结果，取得它下一个距离最近的虚拟节点，然后对应获得实际的节点。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139 /** * ConsistentHashLoadBalance * * 一致性 Hash，相同参数的请求总是发到同一提供者。 * 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 */public class ConsistentHashLoadBalance extends AbstractLoadBalance &#123; /** * 服务方法与一致性哈希选择器的映射 * * KEY：serviceKey + "." + methodName */ private final ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = new ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;(); @SuppressWarnings("unchecked") @Override protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123; String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName(); // 基于 invokers 集合，根据对象内存地址来计算定义哈希值 int identityHashCode = System.identityHashCode(invokers); // 获得 ConsistentHashSelector 对象。若为空，或者定义哈希值变更（说明 invokers 集合发生变化），进行创建新的 ConsistentHashSelector 对象 ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key); if (selector == null || selector.identityHashCode != identityHashCode) &#123; selectors.put(key, new ConsistentHashSelector&lt;T&gt;(invokers, invocation.getMethodName(), identityHashCode)); selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key); &#125; return selector.select(invocation); &#125; private static final class ConsistentHashSelector&lt;T&gt; &#123; /** * 虚拟节点与 Invoker 的映射关系 */ private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers; /** * 每个Invoker 对应的虚拟节点数 */ private final int replicaNumber; /** * 定义哈希值 */ private final int identityHashCode; /** * 取值参数位置数组 */ private final int[] argumentIndex; ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123; this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;(); // 设置 identityHashCode this.identityHashCode = identityHashCode; URL url = invokers.get(0).getUrl(); // 初始化 replicaNumber this.replicaNumber = url.getMethodParameter(methodName, "hash.nodes", 160); // 初始化 argumentIndex String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, "hash.arguments", "0")); argumentIndex = new int[index.length]; for (int i = 0; i &lt; index.length; i++) &#123; argumentIndex[i] = Integer.parseInt(index[i]); &#125; // 初始化 virtualInvokers for (Invoker&lt;T&gt; invoker : invokers) &#123; String address = invoker.getUrl().getAddress(); // 每四个虚拟结点为一组，为什么这样？下面会说到 for (int i = 0; i &lt; replicaNumber / 4; i++) &#123; // 这组虚拟结点得到惟一名称 byte[] digest = md5(address + i); // Md5是一个16字节长度的数组，将16字节的数组每四个字节一组，分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因 for (int h = 0; h &lt; 4; h++) &#123; // 对于每四个字节，组成一个long值数值，做为这个虚拟节点的在环中的惟一key long m = hash(digest, h); virtualInvokers.put(m, invoker); &#125; &#125; &#125; &#125; public Invoker&lt;T&gt; select(Invocation invocation) &#123; // 基于方法参数，获得 KEY String key = toKey(invocation.getArguments()); // 计算 MD5 值 byte[] digest = md5(key); // 计算 KEY 值 return selectForKey(hash(digest, 0)); &#125; private String toKey(Object[] args) &#123; StringBuilder buf = new StringBuilder(); for (int i : argumentIndex) &#123; if (i &gt;= 0 &amp;&amp; i &lt; args.length) &#123; buf.append(args[i]); &#125; &#125; return buf.toString(); &#125; private Invoker&lt;T&gt; selectForKey(long hash) &#123; // 得到大于当前 key 的那个子 Map ，然后从中取出第一个 key ，就是大于且离它最近的那个 key Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.tailMap(hash, true).firstEntry(); // 不存在，则取 virtualInvokers 第一个 if (entry == null) &#123; entry = virtualInvokers.firstEntry(); &#125; // 存在，则返回 return entry.getValue(); &#125; private long hash(byte[] digest, int number) &#123; return (((long) (digest[3 + number * 4] &amp; 0xFF) &lt;&lt; 24) | ((long) (digest[2 + number * 4] &amp; 0xFF) &lt;&lt; 16) | ((long) (digest[1 + number * 4] &amp; 0xFF) &lt;&lt; 8) | (digest[number * 4] &amp; 0xFF)) &amp; 0xFFFFFFFFL; &#125; // 计算 MD5 private byte[] md5(String value) &#123; MessageDigest md5; try &#123; md5 = MessageDigest.getInstance("MD5"); &#125; catch (NoSuchAlgorithmException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; md5.reset(); byte[] bytes; try &#123; bytes = value.getBytes("UTF-8"); &#125; catch (UnsupportedEncodingException e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; md5.update(bytes); return md5.digest(); &#125; &#125;&#125;负载均衡算法的实现细节这里有几个细节处理：当可用的invoker == 1时，直接返回；当可用的invoker == 2时，轮询调度；当通过负载均衡算法获得的invoker不符合要求时，采用向后偏移的方式获得新的invoker实例；]]></content>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序日记--界面改版]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A5%E8%AE%B0-%E7%95%8C%E9%9D%A2%E6%94%B9%E7%89%88%2F</url>
    <content type="text"><![CDATA[关于小程序的一些记录功能改进依托于小程序的云函数，降请求交由云函数封装和执行；后期考虑加入bing的历史图片和one一个的历史句子；天气界面后期考虑加入更多动画效果，整体更加美观；字体排版现在还是比较凌乱的，所以应该找个css来美化一下的；截图]]></content>
      <tags>
        <tag>小程序</tag>
        <tag>bing</tag>
        <tag>一个</tag>
        <tag>one</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装修收藏盒]]></title>
    <url>%2F2018%2F11%2F16%2F%E8%A3%85%E4%BF%AE%E6%94%B6%E8%97%8F%E7%9B%92%2F</url>
    <content type="text"><![CDATA[即将装修了，所以收藏一些实用的装修资料…装修布置如何将家里布置的温馨]]></content>
      <tags>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高中三年，等你下课]]></title>
    <url>%2F2018%2F11%2F12%2F%E9%AB%98%E4%B8%AD%E4%B8%89%E5%B9%B4%EF%BC%8C%E7%AD%89%E4%BD%A0%E4%B8%8B%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>脑洞</tag>
        <tag>周杰伦</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令大乱炖]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E4%B9%B1%E7%82%96%2F</url>
    <content type="text"><![CDATA[命令行这个东西，就像考试一样，书到用时方恨少。所以，平时积累一些常用的命令行和脚本zookeeper命令zkCli命令1$ zkCli -timeout 5000 -server 127.0.0.1:2181zkServer命令1234567891011121314$ zkServer JMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgUsage: ./zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125;$ zkServer statusJMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgError contacting service. It is probably not running.$ zkServer startJMX enabled by defaultUsing config: /usr/local/etc/zookeeper/zoo.cfgStarting zookeeper ... STARTED]]></content>
      <tags>
        <tag>shell</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql萌新入门指南]]></title>
    <url>%2F2018%2F11%2F04%2Fmysql%E8%90%8C%E6%96%B0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[这里是萌新入门指南，瓢羹同学戳这里&gt;&gt;&gt;-- 插入 INSERT INTO `test-db`.`tb_student` ( `student_name`, `student_no`, `studnet_gender`, `favorite_course` ) VALUES ( 'tomb', 'no.11', '女', '1' ); -- 修改 update `test-db`.`tb_student` set `favorite_course` = '2',`student_name` = 'tombb' where `student_name` like '%b%'; -- 查询 select * from `test-db`.`tb_student` WHERE `student_no` = 'no.11'; select * from `test-db`.`tb_student` WHERE `student_name` = 'tombb'; -- 查询排序 -- asc: ascend的缩写，表示升序 select * from `test-db`.`tb_student` where `studnet_gender` = '男' order by `student_no` asc; -- desc: 表示降序 -- 字符默认按照从左往右的ascii顺序进行排序的 select * from `test-db`.tb_student where `studnet_gender` = '女' order by `student_no` desc; -- 删除 delete from `test-db`.`tb_student` where `student_name` = 'tombb'; -- 找出所有姓张的学生名字 select `student_name` as '学生姓名' from `test-db`.`tb_student` where `student_name` like '张%'; -- 联表查询 学生名称-&gt;课程名称 -- 注意：1.联表查询时，查询连接关键字为 “on”，单表查询连接关键字为 “where”。 -- 2.联表查询时，on后面可以再接where关键字，进行外表的进一步查询 select ts.`student_name`,tc.`course_name` from `tb_student` as ts inner join `tb_course` tc on ts.`favorite_course` = tc.`id`; -- 联表查询 学生名称-&gt;性别（男）-&gt;课程名称,查询条件并列的情况用 or，串联条件用 and。 -- 第一种：条件全写在on 之后的语句中 SELECT ts.`student_name` as '姓名', ts.`studnet_gender` as '性别', tc.`course_name` as '课程名称' FROM tb_student AS ts INNER JOIN `tb_course` tc ON ts.`favorite_course` = tc.`id` and ts.`studnet_gender` = '男'; -- 第二种，where 和 on 一起用,推荐用这种，因为事先先把主表符合要求的结果筛选出来，再与附表匹配，性能更好！ SELECT ts.`student_name` as '姓名', ts.`studnet_gender` as '性别', tc.`course_name` as '课程名称' FROM `tb_student` AS ts INNER JOIN `tb_course` tc ON ts.`favorite_course` = tc.`id` where ts.`studnet_gender` = '男'; -- 统计所有课程被学生喜欢的数量: 课程名称 -&gt; 数量 select tc.`course_name` as '课程名称', count(ts.`id`) as '数量' from `tb_course` as tc LEFT JOIN `tb_student` as ts on tc.`id` = ts.`favorite_course` GROUP BY tc.`id`; -- 这个例子有点难，所以我们先来安利一下 group by -- 根据性别统计学生数量 select `studnet_gender` as '性别', count(`studnet_gender`) as '数量' from `tb_student` GROUP BY `studnet_gender`; select sum( case when `studnet_gender` = '男' then 1 else 0 end ) as '男生数量', sum(case when `studnet_gender` = '女' then 1 else 0 end ) as '女生数量' from `tb_student` ;]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
        <tag>指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末遐思]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%91%A8%E6%9C%AB%E9%81%90%E6%80%9D%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>脑洞</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些令人捧腹的梗]]></title>
    <url>%2F2018%2F10%2F26%2F%E9%82%A3%E4%BA%9B%E4%BB%A4%E4%BA%BA%E6%8D%A7%E8%85%B9%E7%9A%84%E6%A2%97%2F</url>
    <content type="text"><![CDATA[关于程序员的老梗金庸小说人物英文名，你能猜对几个]]></content>
      <tags>
        <tag>脑洞</tag>
        <tag>搞笑</tag>
        <tag>梗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic-job源码浅析-源码分析]]></title>
    <url>%2F2018%2F10%2F25%2Felastic-job%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[核心源码分析核心入口：JobScheduler作业调度器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 作业调度器. * * @author zhangliang * @author caohao */public class JobScheduler &#123; private static final String SCHEDULER_INSTANCE_NAME_SUFFIX = "Scheduler"; private static final String CRON_TRIGGER_IDENTITY_SUFFIX = "Trigger"; //作业启动器 private final JobExecutor jobExecutor; public JobScheduler(final CoordinatorRegistryCenter regCenter, final JobConfiguration jobConfig, final ElasticJobListener... elasticJobListeners) &#123; jobExecutor = new JobExecutor(regCenter, jobConfig, elasticJobListeners); &#125; /** * 初始化作业. */ public void init() &#123; //作业启动器初始化 jobExecutor.init(); //建造者模式构造jobDetail JobDetail jobDetail = JobBuilder.newJob(LiteJob.class).withIdentity(jobExecutor.getJobName()).build(); //保留job的状态信息 jobDetail.getJobDataMap().put("elasticJob", jobExecutor.getElasticJob()); JobScheduleController jobScheduleController; try &#123; //实例化作业调度控制器 jobScheduleController = new JobScheduleController( initializeScheduler(jobDetail.getKey().toString()), jobDetail, jobExecutor.getSchedulerFacade(), Joiner.on("_").join(jobExecutor.getJobName(), CRON_TRIGGER_IDENTITY_SUFFIX)); jobScheduleController.scheduleJob(jobExecutor.getSchedulerFacade().getCron()); &#125; catch (final SchedulerException ex) &#123; throw new JobException(ex); &#125; //向作业注册表注册JobScheduleController实例 JobRegistry.getInstance().addJobScheduleController(jobExecutor.getJobName(), jobScheduleController); &#125; private Scheduler initializeScheduler(final String jobName) throws SchedulerException &#123; //工厂方法构造quartz的Scheduler实例 StdSchedulerFactory factory = new StdSchedulerFactory(); factory.initialize(getBaseQuartzProperties(jobName)); Scheduler result = factory.getScheduler(); //注册Trigger监听事件 result.getListenerManager().addTriggerListener(jobExecutor.getSchedulerFacade().newJobTriggerListener()); return result; &#125; private Properties getBaseQuartzProperties(final String jobName) &#123; Properties result = new Properties(); result.put("org.quartz.threadPool.class", org.quartz.simpl.SimpleThreadPool.class.getName()); //并发执行线程数为1，意味着job任务同步执行，防止同一个任务执行时间过长被多次执行 result.put("org.quartz.threadPool.threadCount", "1"); result.put("org.quartz.scheduler.instanceName", Joiner.on("_").join(jobName, SCHEDULER_INSTANCE_NAME_SUFFIX)); if (!jobExecutor.getSchedulerFacade().isMisfire()) &#123; result.put("org.quartz.jobStore.misfireThreshold", "1"); &#125; prepareEnvironments(result); return result; &#125; //钩子方法，用于子类覆盖 protected void prepareEnvironments(final Properties props) &#123; &#125; &#125;作业启动器的init方法1234567891011121314151617181920212223242526272829303132333435363738/** * JobExecutor * 初始化作业. */ public void init() &#123; log.debug("Elastic job: job controller init, job name is: &#123;&#125;.", jobName); //清除上次secheduler的信息 schedulerFacade.clearPreviousServerStatus(); //向注册中心注册当前job regCenter.addCacheData("/" + jobName); //门面类执行具体业务初始化工作 schedulerFacade.registerStartUpInfo(); &#125; /** * SchedulerFacade门面类 * 注册Elastic-Job启动信息. */ public void registerStartUpInfo() &#123; //启动所有监听事件 listenerManager.startAllListeners(); //强制主节点选举 leaderElectionService.leaderForceElection(); //持久化分布式作业配置信息 configService.persistJobConfiguration(); //持久化作业服务器上线相关信息 serverService.persistServerOnline(); //清除暂停作业的标记 serverService.clearJobPausedStatus(); if (JobType.DATA_FLOW == configService.getJobType()) &#123; //异步开启定时批量统计处理数据数量的作业 statisticsService.startProcessCountJob(); &#125; //设置需要重新分片的标记 shardingService.setReshardingFlag(); //初始化作业监听服务 monitorService.listen(); &#125;作业注册表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 作业注册表. * * @author zhangliang * @author caohao *///多线程双检锁：保证单例线程安全@NoArgsConstructor(access = AccessLevel.PRIVATE)public final class JobRegistry &#123; //为什么要用volatile关键字？ private static volatile JobRegistry instance; //全局的作业被以map形式缓存在注册表单例中 private Map&lt;String, JobScheduleController&gt; schedulerMap = new ConcurrentHashMap&lt;&gt;(); /** * 获取作业注册表实例. * * @return 作业注册表实例 */ public static JobRegistry getInstance() &#123; if (null == instance) &#123; synchronized (JobRegistry.class) &#123; if (null == instance) &#123; //实际上实例化分为分配内存和执行构造方法两部分，如果不加volatile，会导致指令重排序，导致构造方法先被执行。 //而另一个线程到达临界区代码段，从而获取到一个未被完全实例化的instance。 instance = new JobRegistry(); &#125; &#125; &#125; return instance; &#125; /** * 添加作业调度控制器. * * @param jobName 作业名称 * @param jobScheduleController 作业调度控制器 */ public void addJobScheduleController(final String jobName, final JobScheduleController jobScheduleController) &#123; schedulerMap.put(jobName, jobScheduleController); &#125; /** * 获取作业调度控制器. * * @param jobName 作业名称 * @return 作业调度控制器 */ public JobScheduleController getJobScheduleController(final String jobName) &#123; return schedulerMap.get(jobName); &#125;&#125;JobExecutor作业启动器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 作业启动器. * * @author zhangliang */@Slf4j@Getterpublic class JobExecutor &#123; private final String jobName; //分布式注册中心 private final CoordinatorRegistryCenter regCenter; //作业具体执行器 private final ElasticJob elasticJob; //为调度器提供内部服务的门面类 private final SchedulerFacade schedulerFacade; /** * 初始化作业. */ public void init() &#123; log.debug("Elastic job: job controller init, job name is: &#123;&#125;.", jobName); //清楚上次作业状态信息 schedulerFacade.clearPreviousServerStatus(); //向注册中心注册当前任务 regCenter.addCacheData("/" + jobName); //注册Elastic-Job启动信息 schedulerFacade.registerStartUpInfo(); &#125; public JobExecutor(final CoordinatorRegistryCenter regCenter, final JobConfiguration jobConfig, final ElasticJobListener... elasticJobListeners) &#123; jobName = jobConfig.getJobName(); this.regCenter = regCenter; List&lt;ElasticJobListener&gt; elasticJobListenerList = Arrays.asList(elasticJobListeners); setGuaranteeServiceForElasticJobListeners(regCenter, jobConfig, elasticJobListenerList); elasticJob = createElasticJob(jobConfig, elasticJobListenerList); schedulerFacade = new SchedulerFacade(regCenter, jobConfig, elasticJobListenerList); &#125; private void setGuaranteeServiceForElasticJobListeners(final CoordinatorRegistryCenter regCenter, final JobConfiguration jobConfig, final List&lt;ElasticJobListener&gt; elasticJobListeners) &#123; GuaranteeService guaranteeService = new GuaranteeService(regCenter, jobConfig); for (ElasticJobListener each : elasticJobListeners) &#123; if (each instanceof AbstractDistributeOnceElasticJobListener) &#123; ((AbstractDistributeOnceElasticJobListener) each).setGuaranteeService(guaranteeService); &#125; &#125; &#125; private ElasticJob createElasticJob(final JobConfiguration jobConfig, final List&lt;ElasticJobListener&gt; elasticJobListenerList) &#123; ElasticJob result; try &#123; result = (ElasticJob) jobConfig.getJobClass().newInstance(); &#125; catch (final InstantiationException | IllegalAccessException ex) &#123; throw new JobException(ex); &#125; result.setJobFacade(new JobFacade(regCenter, jobConfig, elasticJobListenerList)); return result; &#125;&#125;注册中心模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Override public void init() &#123; //如果开关开启，则启动zk内部服务器，提供job节点注册服务 if (zkConfig.isUseNestedZookeeper()) &#123; NestedZookeeperServers.getInstance().startServerIfNotStarted(zkConfig.getNestedPort(), zkConfig.getNestedDataDir()); &#125; log.debug("Elastic job: zookeeper registry center init, server lists is: &#123;&#125;.", zkConfig.getServerLists()); //创建zk连接客户端 Builder builder = CuratorFrameworkFactory.builder() .connectString(zkConfig.getServerLists()) .retryPolicy(new ExponentialBackoffRetry( zkConfig.getBaseSleepTimeMilliseconds(), zkConfig.getMaxRetries(), zkConfig.getMaxSleepTimeMilliseconds())) .namespace(zkConfig.getNamespace()); if (0 != zkConfig.getSessionTimeoutMilliseconds()) &#123; builder.sessionTimeoutMs(zkConfig.getSessionTimeoutMilliseconds()); &#125; if (0 != zkConfig.getConnectionTimeoutMilliseconds()) &#123; builder.connectionTimeoutMs(zkConfig.getConnectionTimeoutMilliseconds()); &#125; //根据配置，开启权限验证 if (!Strings.isNullOrEmpty(zkConfig.getDigest())) &#123; builder.authorization("digest", zkConfig.getDigest().getBytes(Charset.forName("UTF-8"))) .aclProvider(new ACLProvider() &#123; @Override public List&lt;ACL&gt; getDefaultAcl() &#123; return ZooDefs.Ids.CREATOR_ALL_ACL; &#125; @Override public List&lt;ACL&gt; getAclForPath(final String path) &#123; return ZooDefs.Ids.CREATOR_ALL_ACL; &#125; &#125;); &#125; client = builder.build(); client.start(); try &#123; //客户端锁定并尝试连接注册中心 client.blockUntilConnected(zkConfig.getMaxSleepTimeMilliseconds() * zkConfig.getMaxRetries(), TimeUnit.MILLISECONDS); if (!client.getZookeeperClient().isConnected()) &#123; throw new KeeperException.OperationTimeoutException(); &#125; if (!Strings.isNullOrEmpty(zkConfig.getLocalPropertiesPath())) &#123; //根据路径读取配置文件，并创建节点 fillData(); &#125; //CHECKSTYLE:OFF &#125; catch (final Exception ex) &#123; //CHECKSTYLE:ON RegExceptionHandler.handleException(ex); &#125; &#125;plugin模块中的三种作业类型elastic-job提供了三种类型的作业：Simple类型作业、Dataflow类型作业、Script类型作业。这里主要讲解前两者。Script类型作业意为脚本类型作业，支持shell，python，perl等所有类型脚本，使用不多，可以参见github文档。SimpleJob需要实现SimpleJob接口，意为简单实现，未经过任何封装，与quartz原生接口相似，比如示例代码中所使用的job。12345678910111213141516171819202122232425/** * 简单的分布式作业. * * &lt;p&gt; * 仅保证作业可被分布式定时调用, 不提供任何作业处理逻辑. * &lt;/p&gt; * * @author zhangliang * @author caohao */@Slf4jpublic abstract class AbstractSimpleElasticJob extends AbstractElasticJob &#123; @Override protected final void executeJob(final JobExecutionMultipleShardingContext shardingContext) &#123; process(shardingContext); &#125; /** * 执行作业. * * @param shardingContext 作业分片规则配置上下文 */ public abstract void process(final JobExecutionMultipleShardingContext shardingContext);&#125;Dataflow类型用于处理数据流，需实现DataflowJob接口。该接口提供2个方法可供覆盖，分别用于抓取(fetchData)和处理(processData)数据。可通过DataflowJobConfiguration配置是否流式处理。流式处理数据只有fetchData方法的返回值为null或集合长度为空时，作业才停止抓取，否则作业将一直运行下去； 非流式处理数据则只会在每次作业执行过程中执行一次fetchData方法和processData方法，随即完成本次作业。实际开发中，Dataflow类型的job还是很有好用的。12345678910111213141516171819202122232425262728293031323334353637383940/** * 保证同一分片顺序性的批量处理数据流程的作业. * * @author zhangliang * * @param &lt;T&gt; 数据流作业处理的数据实体类型 */public abstract class AbstractBatchSequenceDataFlowElasticJob&lt;T&gt; extends AbstractBatchDataFlowElasticJob&lt;T, JobExecutionSingleShardingContext&gt; &#123;&#125;/** * 高吞吐量批量处理数据流程的作业. * * @author zhangliang * * @param &lt;T&gt; 数据流作业处理的数据实体类型 */public abstract class AbstractBatchThroughputDataFlowElasticJob&lt;T&gt; extends AbstractBatchDataFlowElasticJob&lt;T, JobExecutionMultipleShardingContext&gt; &#123;&#125;/** * 保证同一分片顺序性的逐条处理数据流程的作业. * * @author zhangliang * * @param &lt;T&gt; 数据流作业处理的数据实体类型 */public abstract class AbstractIndividualSequenceDataFlowElasticJob&lt;T&gt; extends AbstractIndividualDataFlowElasticJob&lt;T, JobExecutionSingleShardingContext&gt; &#123;&#125;/** * 高吞吐量逐条处理数据流程的作业. * * @author zhangliang * * @param &lt;T&gt; 数据流作业处理的数据实体类型 */public abstract class AbstractIndividualThroughputDataFlowElasticJob&lt;T&gt; extends AbstractIndividualDataFlowElasticJob&lt;T, JobExecutionMultipleShardingContext&gt; &#123;&#125;plugin中的分片策略AverageAllocationJobShardingStrategy：基于平均分配算法的分片策略；OdevitySortByNameJobShardingStrategy：根据作业名的哈希值奇偶数决定IP升降序算法的分片策略；RotateServerByNameJobShardingStrategy：根据作业名的哈希值对服务器列表进行轮转的分片策略；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 基于平均分配算法的分片策略. * * &lt;p&gt; * 如果分片不能整除, 则不能整除的多余分片将依次追加到序号小的服务器. * 如: * 1. 如果有3台服务器, 分成9片, 则每台服务器分到的分片是: 1=[0,1,2], 2=[3,4,5], 3=[6,7,8]. * 2. 如果有3台服务器, 分成8片, 则每台服务器分到的分片是: 1=[0,1,6], 2=[2,3,7], 3=[4,5]. * 3. 如果有3台服务器, 分成10片, 则每台服务器分到的分片是: 1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8]. * &lt;/p&gt; * * @author zhangliang */public final class AverageAllocationJobShardingStrategy implements JobShardingStrategy &#123; @Override public Map&lt;String, List&lt;Integer&gt;&gt; sharding(final List&lt;String&gt; serversList, final JobShardingStrategyOption option) &#123; if (serversList.isEmpty()) &#123; return Collections.emptyMap(); &#125; Map&lt;String, List&lt;Integer&gt;&gt; result = shardingAliquot(serversList, option.getShardingTotalCount()); addAliquant(serversList, option.getShardingTotalCount(), result); return result; &#125; //平均分配前面若干项 private Map&lt;String, List&lt;Integer&gt;&gt; shardingAliquot(final List&lt;String&gt; serversList, final int shardingTotalCount) &#123; Map&lt;String, List&lt;Integer&gt;&gt; result = new LinkedHashMap&lt;&gt;(serversList.size()); int itemCountPerSharding = shardingTotalCount / serversList.size(); int count = 0; for (String each : serversList) &#123; List&lt;Integer&gt; shardingItems = new ArrayList&lt;&gt;(itemCountPerSharding + 1); for (int i = count * itemCountPerSharding; i &lt; (count + 1) * itemCountPerSharding; i++) &#123; shardingItems.add(i); &#125; result.put(each, shardingItems); count++; &#125; return result; &#125; //追加不能整除的分片索引 private void addAliquant(final List&lt;String&gt; serversList, final int shardingTotalCount, final Map&lt;String, List&lt;Integer&gt;&gt; shardingResult) &#123; int aliquant = shardingTotalCount % serversList.size(); int count = 0; for (Entry&lt;String, List&lt;Integer&gt;&gt; entry : shardingResult.entrySet()) &#123; if (count &lt; aliquant) &#123; entry.getValue().add(shardingTotalCount / serversList.size() * serversList.size() + count); &#125; count++; &#125; &#125;&#125;123456789101112131415161718192021222324252627/** * 根据作业名的哈希值奇偶数决定IP升降序算法的分片策略. * * &lt;p&gt; * 作业名的哈希值为奇数则IP升序. * 作业名的哈希值为偶数则IP降序. * 用于不同的作业平均分配负载至不同的服务器. * 如: * 1. 如果有3台服务器, 分成2片, 作业名称的哈希值为奇数, 则每台服务器分到的分片是: 1=[0], 2=[1], 3=[]. * 2. 如果有3台服务器, 分成2片, 作业名称的哈希值为偶数, 则每台服务器分到的分片是: 3=[0], 2=[1], 1=[]. * &lt;/p&gt; * * @author zhangliang */public final class OdevitySortByNameJobShardingStrategy implements JobShardingStrategy &#123; private AverageAllocationJobShardingStrategy averageAllocationJobShardingStrategy = new AverageAllocationJobShardingStrategy(); @Override public Map&lt;String, List&lt;Integer&gt;&gt; sharding(final List&lt;String&gt; serversList, final JobShardingStrategyOption option) &#123; long jobNameHash = option.getJobName().hashCode(); if (0 == jobNameHash % 2) &#123; Collections.reverse(serversList); &#125; return averageAllocationJobShardingStrategy.sharding(serversList, option); &#125;&#125;1234567891011121314151617181920212223242526272829/** * 根据作业名的哈希值对服务器列表进行轮转的分片策略. * 向左偏移offset位之后进行平均分配 * * @author weishubin */public class RotateServerByNameJobShardingStrategy implements JobShardingStrategy &#123; private AverageAllocationJobShardingStrategy averageAllocationJobShardingStrategy = new AverageAllocationJobShardingStrategy(); @Override public Map&lt;String, List&lt;Integer&gt;&gt; sharding(final List&lt;String&gt; serversList, final JobShardingStrategyOption option) &#123; return averageAllocationJobShardingStrategy.sharding(rotateServerList(serversList, option.getJobName()), option); &#125; private List&lt;String&gt; rotateServerList(final List&lt;String&gt; serversList, final String jobName) &#123; int serverSize = serversList.size(); int offset = Math.abs(jobName.hashCode()) % serverSize; if (0 == offset) &#123; return serversList; &#125; List&lt;String&gt; result = new ArrayList&lt;&gt;(serverSize); for (int i = 0; i &lt; serverSize; i++) &#123; int index = (i + offset) % serverSize; result.add(serversList.get(index)); &#125; return result; &#125;&#125;]]></content>
      <tags>
        <tag>elastic-job</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic-job源码浅析-任务执行过程]]></title>
    <url>%2F2018%2F10%2F25%2Felastic-job%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[启动过程流程图流程图详细地描述了各个作业细节的执行过程，看上去流程非常复杂，其主要的功能点为：判断作业是否可执行，判断作业是否分片执行，作业执行状态监听，作业失效转移等。下面我们结合代码一步步窥探他的执行过程。核心源码分析作业入口123456789101112131415/** * Elastic Job Lite提供的Quartz封装作业. * * @author zhangliang */public class LiteJob implements Job &#123; @Setter private ElasticJob elasticJob; @Override public void execute(final JobExecutionContext context) throws JobExecutionException &#123; elasticJob.execute(); &#125;&#125;LiteJob实现了Quartz的Job接口，并且持有elasticJob的实现类，通过代理的方式实现了ElasticJob与Quartz的无缝衔接；【亮点】这是一种典型的代理模式，其好处在于体验上完全与Quartz的Job一致，并且遵循了代码的开闭原则，使得代码具有很好地拓展性：例如ElasticJob接口有SimpleJob，DataFlowJob或者用户自定义的多种实现类，因此具有很好地拓展性。AbstractElasticJob抽象类及其原理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 弹性化分布式作业的基类. * * @author zhangliang * @author caohao */@Slf4jpublic abstract class AbstractElasticJob implements ElasticJob &#123; //具体的业务实现放在jobFacade门面类中实现，简化代码复杂度 private JobFacade jobFacade; @Override public final void execute() &#123; log.trace("Elastic job: job execute begin."); //判断与注册中心时间差是否在允许范围内 jobFacade.checkMaxTimeDiffSecondsTolerable(); //获取分片上下文 JobExecutionMultipleShardingContext shardingContext = jobFacade.getShardingContext(); //若前面的任务仍在执行，则设置错过执行标记，延迟执行 if (jobFacade.misfireIfNecessary(shardingContext.getShardingItems())) &#123; log.debug("Elastic job: previous job is still running, new job will start after previous job completed. Misfired job had recorded."); return; &#125; //清除作业上次执行的信息 jobFacade.cleanPreviousExecutionInfo(); try &#123; //各监听器执行job执行前方法 jobFacade.beforeJobExecuted(shardingContext); //CHECKSTYLE:OFF &#125; catch (final Throwable cause) &#123; //CHECKSTYLE:ON handleJobExecutionException(new JobException(cause)); &#125; //执行具体的job业务逻辑 executeJobInternal(shardingContext); log.trace("Elastic job: execute normal completed, sharding context:&#123;&#125;.", shardingContext); while (jobFacade.isExecuteMisfired(shardingContext.getShardingItems())) &#123; log.trace("Elastic job: execute misfired job, sharding context:&#123;&#125;.", shardingContext); jobFacade.clearMisfire(shardingContext.getShardingItems()); executeJobInternal(shardingContext); log.trace("Elastic job: misfired job completed, sharding context:&#123;&#125;.", shardingContext); &#125; //按需失效转移 jobFacade.failoverIfNecessary(); try &#123; //执行监听后事件 jobFacade.afterJobExecuted(shardingContext); //CHECKSTYLE:OFF &#125; catch (final Throwable cause) &#123; //CHECKSTYLE:ON handleJobExecutionException(new JobException(cause)); &#125; log.trace("Elastic job: execute all completed."); &#125; private void executeJobInternal(final JobExecutionMultipleShardingContext shardingContext) &#123; if (shardingContext.getShardingItems().isEmpty()) &#123; log.trace("Elastic job: sharding item is empty, job execution context:&#123;&#125;.", shardingContext); return; &#125; //注册任务执行信息 jobFacade.registerJobBegin(shardingContext); try &#123; executeJob(shardingContext); //CHECKSTYLE:OFF &#125; catch (final Throwable cause) &#123; //CHECKSTYLE:ON handleJobExecutionException(new JobException(cause)); &#125; finally &#123; // TODO 考虑增加作业失败的状态，并且考虑如何处理作业失败的整体回路 jobFacade.registerJobCompleted(shardingContext); &#125; &#125; protected abstract void executeJob(final JobExecutionMultipleShardingContext shardingContext); @Override public void handleJobExecutionException(final JobException jobException) &#123; log.error("Elastic job: exception occur in job processing...", jobException.getCause()); &#125; @Override public final JobFacade getJobFacade() &#123; return jobFacade; &#125; @Override public final void setJobFacade(final JobFacade jobFacade) &#123; this.jobFacade = jobFacade; &#125;【亮点】外观模式传送门上面的代码中应用到了外观模式（Facade），AbstractElasticJob持有jobFacade对象，Elasticjob负责统筹整体的job执行流程但无需关注业务的具体实现，转而将复杂的业务处理逻辑交由jobFacade中的方法进行处理，从而将job与具体的业务逻辑抽离出来方便阅读和拓展。]]></content>
      <tags>
        <tag>elastic-job</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic-job源码浅析-任务初始化]]></title>
    <url>%2F2018%2F10%2F25%2Felastic-job%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E4%BB%BB%E5%8A%A1%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[作业过程源码分析核心入口：JobScheduler作业调度器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 作业调度器. * * @author zhangliang * @author caohao */public class JobScheduler &#123; private static final String SCHEDULER_INSTANCE_NAME_SUFFIX = "Scheduler"; private static final String CRON_TRIGGER_IDENTITY_SUFFIX = "Trigger"; //作业启动器 private final JobExecutor jobExecutor; public JobScheduler(final CoordinatorRegistryCenter regCenter, final JobConfiguration jobConfig, final ElasticJobListener... elasticJobListeners) &#123; jobExecutor = new JobExecutor(regCenter, jobConfig, elasticJobListeners); &#125; /** * 初始化作业. */ public void init() &#123; //作业启动器初始化 jobExecutor.init(); //建造者模式构造jobDetail JobDetail jobDetail = JobBuilder.newJob(LiteJob.class).withIdentity(jobExecutor.getJobName()).build(); //保留job的状态信息 jobDetail.getJobDataMap().put("elasticJob", jobExecutor.getElasticJob()); JobScheduleController jobScheduleController; try &#123; //实例化作业调度控制器 jobScheduleController = new JobScheduleController( initializeScheduler(jobDetail.getKey().toString()), jobDetail, jobExecutor.getSchedulerFacade(), Joiner.on("_").join(jobExecutor.getJobName(), CRON_TRIGGER_IDENTITY_SUFFIX)); jobScheduleController.scheduleJob(jobExecutor.getSchedulerFacade().getCron()); &#125; catch (final SchedulerException ex) &#123; throw new JobException(ex); &#125; //向作业注册表注册JobScheduleController实例 JobRegistry.getInstance().addJobScheduleController(jobExecutor.getJobName(), jobScheduleController); &#125; private Scheduler initializeScheduler(final String jobName) throws SchedulerException &#123; //工厂方法构造quartz的Scheduler实例 StdSchedulerFactory factory = new StdSchedulerFactory(); factory.initialize(getBaseQuartzProperties(jobName)); Scheduler result = factory.getScheduler(); //注册Trigger监听事件 result.getListenerManager().addTriggerListener(jobExecutor.getSchedulerFacade().newJobTriggerListener()); return result; &#125; private Properties getBaseQuartzProperties(final String jobName) &#123; Properties result = new Properties(); result.put("org.quartz.threadPool.class", org.quartz.simpl.SimpleThreadPool.class.getName()); //并发执行线程数为1，意味着job任务同步执行，防止同一个任务执行时间过长被重复执行 result.put("org.quartz.threadPool.threadCount", "1"); result.put("org.quartz.scheduler.instanceName", Joiner.on("_").join(jobName, SCHEDULER_INSTANCE_NAME_SUFFIX)); if (!jobExecutor.getSchedulerFacade().isMisfire()) &#123; result.put("org.quartz.jobStore.misfireThreshold", "1"); &#125; prepareEnvironments(result); return result; &#125; //钩子方法，用于子类覆盖 protected void prepareEnvironments(final Properties props) &#123; &#125; &#125;JobExecutor作业启动器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 作业启动器. * * @author zhangliang */@Slf4j@Getterpublic class JobExecutor &#123; private final String jobName; //分布式注册中心 private final CoordinatorRegistryCenter regCenter; //作业具体执行器 private final ElasticJob elasticJob; //为调度器提供内部服务的门面类 private final SchedulerFacade schedulerFacade; /** * 初始化作业. */ public void init() &#123; log.debug("Elastic job: job controller init, job name is: &#123;&#125;.", jobName); //清楚上次作业状态信息 schedulerFacade.clearPreviousServerStatus(); //向注册中心注册当前任务 regCenter.addCacheData("/" + jobName); //注册Elastic-Job启动信息 schedulerFacade.registerStartUpInfo(); &#125; public JobExecutor(final CoordinatorRegistryCenter regCenter, final JobConfiguration jobConfig, final ElasticJobListener... elasticJobListeners) &#123; jobName = jobConfig.getJobName(); this.regCenter = regCenter; List&lt;ElasticJobListener&gt; elasticJobListenerList = Arrays.asList(elasticJobListeners); setGuaranteeServiceForElasticJobListeners(regCenter, jobConfig, elasticJobListenerList); elasticJob = createElasticJob(jobConfig, elasticJobListenerList); schedulerFacade = new SchedulerFacade(regCenter, jobConfig, elasticJobListenerList); &#125; private void setGuaranteeServiceForElasticJobListeners(final CoordinatorRegistryCenter regCenter, final JobConfiguration jobConfig, final List&lt;ElasticJobListener&gt; elasticJobListeners) &#123; GuaranteeService guaranteeService = new GuaranteeService(regCenter, jobConfig); for (ElasticJobListener each : elasticJobListeners) &#123; if (each instanceof AbstractDistributeOnceElasticJobListener) &#123; ((AbstractDistributeOnceElasticJobListener) each).setGuaranteeService(guaranteeService); &#125; &#125; &#125; private ElasticJob createElasticJob(final JobConfiguration jobConfig, final List&lt;ElasticJobListener&gt; elasticJobListenerList) &#123; ElasticJob result; try &#123; result = (ElasticJob) jobConfig.getJobClass().newInstance(); &#125; catch (final InstantiationException | IllegalAccessException ex) &#123; throw new JobException(ex); &#125; result.setJobFacade(new JobFacade(regCenter, jobConfig, elasticJobListenerList)); return result; &#125;&#125;JobFacade门面类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * 为调度器提供内部服务的门面类. * * @author zhangliang */public class SchedulerFacade &#123; private final ConfigurationService configService; private final LeaderElectionService leaderElectionService; private final ServerService serverService; private final ShardingService shardingService; private final ExecutionService executionService; private final StatisticsService statisticsService; private final MonitorService monitorService; private final ListenerManager listenerManager; public SchedulerFacade(final CoordinatorRegistryCenter coordinatorRegistryCenter, final JobConfiguration jobConfiguration, final List&lt;ElasticJobListener&gt; elasticJobListeners) &#123; configService = new ConfigurationService(coordinatorRegistryCenter, jobConfiguration); leaderElectionService = new LeaderElectionService(coordinatorRegistryCenter, jobConfiguration); serverService = new ServerService(coordinatorRegistryCenter, jobConfiguration); shardingService = new ShardingService(coordinatorRegistryCenter, jobConfiguration); executionService = new ExecutionService(coordinatorRegistryCenter, jobConfiguration); statisticsService = new StatisticsService(coordinatorRegistryCenter, jobConfiguration); monitorService = new MonitorService(coordinatorRegistryCenter, jobConfiguration); listenerManager = new ListenerManager(coordinatorRegistryCenter, jobConfiguration, elasticJobListeners); &#125; /** * 每次作业启动前清理上次运行状态. */ public void clearPreviousServerStatus() &#123; serverService.clearPreviousServerStatus(); &#125; /** * 注册Elastic-Job启动信息. */ public void registerStartUpInfo() &#123; //启动各类监听器 listenerManager.startAllListeners(); //强制选举主节点 leaderElectionService.leaderForceElection(); //zk中持久化分布式作业配置信息 configService.persistJobConfiguration(); //zk中持久化作业服务器上线相关信息. serverService.persistServerOnline(); //清除暂停作业的标记. serverService.clearJobPausedStatus(); if (JobType.DATA_FLOW == configService.getJobType()) &#123; //异步开启统计处理数据数量的作业 statisticsService.startProcessCountJob(); &#125; //设置需要重新分片的标记 shardingService.setReshardingFlag(); //初始化作业监控服务 monitorService.listen(); &#125; /** * 释放作业占用的资源. */ public void releaseJobResource() &#123; monitorService.close(); if (JobType.DATA_FLOW.equals(configService.getJobType())) &#123; statisticsService.stopProcessCountJob(); &#125; serverService.removeServerStatus(); &#125; /** * 获取作业启动时间的cron表达式. * * @return 作业启动时间的cron表达式 */ public String getCron() &#123; return configService.getCron(); &#125; /** * 获取是否开启misfire. * * @return 是否开启misfire */ public boolean isMisfire() &#123; return configService.isMisfire(); &#125; /** * 获取作业触发监听器. * * @return 作业触发监听器 */ public JobTriggerListener newJobTriggerListener() &#123; return new JobTriggerListener(executionService, shardingService); &#125;&#125;作业注册表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 作业注册表. * * @author zhangliang * @author caohao *///多线程双检锁：保证单例线程安全@NoArgsConstructor(access = AccessLevel.PRIVATE)public final class JobRegistry &#123; //为什么要用volatile关键字？ private static volatile JobRegistry instance; //全局的作业被以map形式缓存在注册表单例中 private Map&lt;String, JobScheduleController&gt; schedulerMap = new ConcurrentHashMap&lt;&gt;(); /** * 获取作业注册表实例. * * @return 作业注册表实例 */ public static JobRegistry getInstance() &#123; if (null == instance) &#123; synchronized (JobRegistry.class) &#123; if (null == instance) &#123; //实际上实例化分为分配内存和执行构造方法两部分，如果不加volatile，会导致指令重排序，导致构造方法先被执行。 //而另一个线程到达临界区代码段，从而获取到一个未被完全实例化的instance。 instance = new JobRegistry(); &#125; &#125; &#125; return instance; &#125; /** * 添加作业调度控制器. * * @param jobName 作业名称 * @param jobScheduleController 作业调度控制器 */ public void addJobScheduleController(final String jobName, final JobScheduleController jobScheduleController) &#123; schedulerMap.put(jobName, jobScheduleController); &#125; /** * 获取作业调度控制器. * * @param jobName 作业名称 * @return 作业调度控制器 */ public JobScheduleController getJobScheduleController(final String jobName) &#123; return schedulerMap.get(jobName); &#125;&#125;]]></content>
      <tags>
        <tag>elastic-job</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elastic-job源码浅析-架构篇]]></title>
    <url>%2F2018%2F10%2F25%2Felastic-job%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E6%9E%B6%E6%9E%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[源码阅读小技巧传送门写在前面elastic-job是当当开源的一款非常好用的作业框架，在此之前，任务调度的主流框架是quartZ或者spring-task。两者均不能很好地支持高并发量的分布式任务调度，即使是号称拥有集群能力的quartZ也仅仅保证了job的高可用，单一时刻只能有一台机器执行具体的调度任务。因此，老牌劲旅无法解决两个迫切的需求点：1.quartZ的集群仅仅是用于实现HA（high avalible),无法实现高并发；2.无论quartZ还是spring-task，均无法很好地实现水平拓展；1Elastic-Job is a distributed scheduled job framework, based on Quartz and Zookeeper.上述文字是elastic-job github主页对它的描述，从上面的描述中我们可以看到两个关键字Quartz和Zookeeper，基于以上两个基础框架，Elastic-job实现了高可用和高并发。elastic-job解决了那些问题举个典型的job场景，比如余额宝里的昨日收益，系统需要job在每天某个时间点开始，给所有余额宝用户计算收益。如果用户数量不多，我们可以轻易使用quartz来完成，我们让计息job在某个时间点开始执行，循环遍历所有用户计算利息，这没问题。可是，如果用户体量特别大，我们可能会面临着在第二天之前处理不完这么多用户。另外，我们部署job的时候也得注意，我们可能会把job直接放在我们的webapp里，webapp通常是多节点部署的，这样，我们的job也就是多节点，多个job同时执行，很容易造成重复执行，比如用户重复计息，为了避免这种情况，我们可能会对job的执行加锁，保证始终只有一个节点能执行，或者干脆让job从webapp里剥离出来，独自部署一个节点。elastic-job就可以帮助我们解决上面的问题，elastic底层的任务调度还是使用的quartz，通过zookeeper来动态给job节点分片。我们来看：很大体量的用户需要在特定的时间段内计息完成我们肯定是希望我们的任务可以通过集群达到水平扩展，集群里的每个节点都处理部分用户，不管用户数量有多庞大，我们只要增加机器就可以了，比如单台机器特定时间能处理n个用户，2台机器处理2n个用户，3台3n，4台4n…，再多的用户也不怕了。使用elastic-job开发的作业都是zookeeper的客户端，比如我希望3台机器跑job，我们将任务分成3片，框架通过zk的协调，最终会让3台机器分别分配到0,1,2的任务片，比如server0–&gt;0，server1–&gt;1，server2–&gt;2，当server0执行时，可以只查询id%3==0的用户，server1执行时，只查询id%3==1的用户，server2执行时，只查询id%3==2的用户。任务部署多节点引发重复执行在上面的基础上，我们再增加server3，此时，server3分不到任务分片，因为只有3片，已经分完了。没有分到任务分片的作业程序将不执行。如果此时server2挂了，那么server2的分片项会分配给server3，server3有了分片，就会替代server2执行。如果此时server3也挂了，只剩下server0和server1了，框架也会自动把server3的分片随机分配给server0或者server1，可能会这样，server0–&gt;0，server1–&gt;1,2。这种特性称之为弹性扩容，即elastic-job名称的由来。上述的引用比较冗长，简单地理解就是elastic-job利用zk的分布式集群管理能力，对job节点进行的弹性扩容和收缩。同时任务分片的方式保证了job执行的并发能力和防止重复执行，使任务调度不仅拥有高可用，也具备了水平拓展和高并发能力。elastic-job结构elastic-job架构图任务节点数据结构elastic-job模块简析core的主要的模块分为:job模块：plugin(内含三种不同的作业类型,分片策略)，api(对外暴露的api服务)，exception(异常类)，internal(内部模块)reg(注册中心)模块：base(基类)，异常处理模块，zookeeper注册中心模块]]></content>
      <tags>
        <tag>elastic-job</tag>
        <tag>源码</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo优化攻略]]></title>
    <url>%2F2018%2F10%2F25%2Fhexo%E4%BC%98%E5%8C%96%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[写在前面这个攻略主要是给有一定diy能力的hexo博主。一些细节的攻略可以参考如下文章：hexo 基础配置优化插件进阶静态代码压缩文章比较长的情况下网页往往会显示地较慢。因此，需要对静态代码进行压缩，以提高网站的响应速度。1npm install hexo-all-minifier --save在hexo根目录下的_config.yml中配置:12345678910111213141516171819202122232425262728# 代码压缩 github.com/chenzhutian/hexo-all-minifierall_minifier: truehtml_minifier: enable: true ignore_error: false exclude: css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: false # 图片不压缩 interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false文章加密插件安装1npm install hexo-encrypt --save在项目_config.yml中声名默认密码123#该密码为全局默认密码encrypt: password: 你的密码在文章头加入密码配置12encrypt: trueenc_pwd: 你的文章独立密码在根目录的package.json中追加配置，记得补全“,”1"hexo-encrypt": "^0.2.0"最终效果网站顶部进度条在{hexo-path}/themes/next/layout/_partials/head/head.swig中顶部加入如下代码123456789101112131415&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;&lt;style&gt;.pace .pace-progress &#123; background: #f6a427; /*进度条颜色*/ height: 3px;&#125;.pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/&#125;.pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/&#125;&lt;/style&gt;效果图]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>优化</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于装修的一点想法]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%85%B3%E4%BA%8E%E8%A3%85%E4%BF%AE%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[装修风格的讨论在这个宅基地很难批准的时候，终于可以造房子了。楼房的样式是那种两层平层 + 一层别墅式的样子，虽然比不上欧式的新颖，但是空间足够大，四平八稳的风格还算能接受。对于装修风格，和瓢羹同学也有一些讨论。一开始瓢羹同学认为欧式的辉煌装修风格不错，但是我觉得有点老土。于是呢，她说北欧性冷风不错，我也觉得可以，只是美中不足的是有点暗色调，不适合居家。我呢，有点青睐于和风的风格，比较的小资。但是，作为自建房格调又显得有点小气了。所以，经过一番博弈，我们最终把两种风格进行了mix——其实我们不是一定青睐和风，亦或是北欧。后来我们发现，我们只是对原木风比较感冒。原木材质的纹理，配合较大空间的色彩搭配，整体给人一种居家的舒适感和归属感。同时，又比较有格调。要准备的工作从目前来看打的轮廓和格局已经敲定了，但是整体装修的渲染还没出来，准备抽空到酷家乐搞一波装修效果图。到时候看看整体下来的装修效果如何。全景预览全景图传送门装修效果图装修资料酷家乐 有好几套比较合理的和风装修来自酷家乐，吊顶采用了比较简约的纯白+造型别致的灯具，这个风格我们都比较喜欢。易盖房 小别墅一些样式比较讨巧，看着比较舒服。]]></content>
      <tags>
        <tag>酷玩</tag>
        <tag>装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员养生秘笈]]></title>
    <url>%2F2018%2F10%2F21%2F%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%85%BB%E7%94%9F%2F</url>
    <content type="text"><![CDATA[function doDecrypt (pwd, onError) { console.log('in doDecrypt'); const txt = document.getElementById('enc_content').innerHTML; let plantext; try { const bytes = CryptoJS.AES.decrypt(txt, pwd); var plaintext = bytes.toString(CryptoJS.enc.Utf8); } catch(err) { if(onError) { onError(err); } return; } document.getElementById('enc_content').innerHTML = plaintext; document.getElementById('enc_content').style.display = 'block'; document.getElementById('enc_passwd').style.display = 'none'; if(typeof MathJax !== 'undefined') { MathJax.Hub.Queue( ['resetEquationNumbers', MathJax.InputJax.TeX], ['PreProcess', MathJax.Hub], ['Reprocess', MathJax.Hub] ); } } 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 var onError = function(error) { document.getElementById("enc_error").innerHTML = "password error!" }; function decrypt() { var passwd = document.getElementById("enc_pwd_input").value; console.log(passwd); doDecrypt(passwd, onError); }]]></content>
      <tags>
        <tag>程序员</tag>
        <tag>养生</tag>
        <tag>码农</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 源码阅读]]></title>
    <url>%2F2018%2F10%2F19%2Fspring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[对于spring源码的一些个人的见解！！！spring 核心代码12345参考资料：spring源码深度解析Spring版本：Spring-4.3.5-RELEASE吐槽下，老外写的东西真晕啊，像亲妈一样啰啰嗦嗦帮你考虑了各种情况，然后最好还不忘加一句：如果你不满意，还可以拓展！！！核心流程初始化过程非常清晰的模板方法，每一个步骤封装成一个具体的函数进行代理，职责清晰明了；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //预热，做准备工作 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. //获取内部的bean factory ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. //预热beanFactory prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. //beanFactory在上下文中注册bean，核心的代码就在这里 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // bean创建的时候拦截并注册bean处理器，这里只创建处理器，真正的创建是在getBean(..)方法里 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 用于支持国际化，比如一些日志的国际化匹配等； initMessageSource(); // 为上下文初始化消息传播工具 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 钩子方法：额外的beans处理方法 onRefresh(); // Check for listener beans and register them. // 注册监听器 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 实例化非延时加载的bean单例 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // push beans创建完成的消息 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125;spring 类加载的基本类spring DefaultListableBeanFactory UML示意图：spring bean 创建过程转换beanName尝试从缓存中获取单例bean本身的实例化原型模式依赖检测parentBeanFactory 检测将gernerecBeanDefinition 转换成 RootBeanDefination寻找依赖根据scope 初始化(init)对应的bean类型转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/** * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve * @param requiredType the required type of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @param typeCheckOnly whether the instance is obtained for a type check, * not for actual use * @return an instance of the bean * @throws BeansException if the bean could not be created */@SuppressWarnings("unchecked")protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; //转换beanName，我们知道在spring中，bean factory的名称都是类似于 &amp;org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory //因此获取的时候需要进行转换 final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. // 尝试从缓存中获取单例 Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference"); &#125; else &#123; logger.debug("Returning cached instance of singleton bean '" + beanName + "'"); &#125; &#125; //实例化 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Fail if we're already creating this bean instance: // We're assumably within a circular reference. // 检测当前依赖的类是否正在创建，如果是，则抛出异常 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. // 如果bean配置不存在则只能去父工厂找 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; //转换并合并BeanDefinition属性 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. // 原型模式的bean需要循环检测依赖 防止出现A-&gt;B-&gt;A 的循环依赖情况出现 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'"); &#125; registerDependentBean(dep, beanName); getBean(dep); &#125; &#125; // Create bean instance. // 创建bean实例 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; consider " + "defining a scoped proxy for this bean if you intend to refer to it from a singleton", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. // 转换bean类型 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125;spring事务隔离级别及事务传播实现propagation_requierd(spring的事务默认是该级别)：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * Create a TransactionStatus for an existing transaction. */private TransactionStatus handleExistingTransaction( TransactionDefinition definition, Object transaction, boolean debugEnabled) throws TransactionException &#123; //若为非事务方式，则抛异常 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123; throw new IllegalTransactionStateException( "Existing transaction found for transaction marked with propagation 'never'"); &#125; // 若存在事务，挂起适当前事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123; if (debugEnabled) &#123; logger.debug("Suspending current transaction"); &#125; // 挂起当前事务 Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources); &#125; // 挂起当前事务，并新建事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123; if (debugEnabled) &#123; logger.debug("Suspending current transaction, creating new transaction with name [" + definition.getName() + "]"); &#125; //挂起当前事务 SuspendedResourcesHolder suspendedResources = suspend(transaction); try &#123; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); // 重新开启事务 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; &#125; catch (RuntimeException beginEx) &#123; resumeAfterBeginException(transaction, suspendedResources, beginEx); throw beginEx; &#125; catch (Error beginErr) &#123; resumeAfterBeginException(transaction, suspendedResources, beginErr); throw beginErr; &#125; &#125; // 若当前事务存在，则嵌套执行事务 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; if (!isNestedTransactionAllowed()) &#123; throw new NestedTransactionNotSupportedException( "Transaction manager does not allow nested transactions by default - " + "specify 'nestedTransactionAllowed' property with value 'true'"); &#125; if (debugEnabled) &#123; logger.debug("Creating nested transaction with name [" + definition.getName() + "]"); &#125; // 判定是否支持事务备份点 if (useSavepointForNestedTransaction()) &#123; // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); // 创建备份点 status.createAndHoldSavepoint(); return status; &#125; else &#123; // Nested transaction through nested begin and commit/rollback calls. // Usually only for JTA: Spring synchronization might get activated here // in case of a pre-existing JTA transaction. boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, null); // 不支持备份点的情况下会新建事务 doBegin(transaction, definition); prepareSynchronization(status, definition); return status; &#125; &#125; // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED. if (debugEnabled) &#123; logger.debug("Participating in existing transaction"); &#125; if (isValidateExistingTransaction()) &#123; if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123; Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel(); if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123; Constants isoConstants = DefaultTransactionDefinition.constants; throw new IllegalTransactionStateException("Participating transaction with definition [" + definition + "] specifies isolation level which is incompatible with existing transaction: " + (currentIsolationLevel != null ? isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) : "(unknown)")); &#125; &#125; if (!definition.isReadOnly()) &#123; if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123; throw new IllegalTransactionStateException("Participating transaction with definition [" + definition + "] is not marked as read-only but existing transaction is"); &#125; &#125; &#125; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);&#125;一些干货aop注入的实现过程doCreateBean中会暴露一个bean引用，用以处理循环引用；同时大家熟知的AOP就是通过getEarlyBeanReference(..)方法植入的；具体的，是在wrapIfNecessary(..) 方法中封装了advice并创建了代理；@Autowired注解的实现doCreateBean(..)中的populateBean(..)方法，实现了基于@Autowired注解的实现，根据名称或类型进行依赖的注入；]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Mvc源码阅读]]></title>
    <url>%2F2018%2F10%2F19%2Fspringmvc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[对springMVC的一些思考!!!Spring Mvc源码阅读12345678910111213SpringMVC核心处理流程：1、DispatcherServlet前端控制器接收发过来的请求，交给HandlerMapping处理器映射器2、HandlerMapping处理器映射器，根据请求路径找到相应的HandlerAdapter处理器适配器（处理器适配器就是那些拦截器或Controller）3、HandlerAdapter处理器适配器，请求数据绑定和转换，处理一些功能请求，返回一个ModelAndView对象（包括模型数据、逻辑视图名）4、ViewResolver视图解析器，先根据ModelAndView中设置的View解析具体视图5、然后再将Model模型中的数据渲染到View上这些过程都是以DispatcherServlet为中轴线进行的。入口源码springMVC的请求会交由dispatcherServlet处理，其本质上是一个多线程的请求处理机制；核心业务逻辑被设计在doDispatcher(..)方法中；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 绑定url -&gt; 具体的handler/Controller.method(..) // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 根据handler绑定具体的adapter // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = "GET".equals(method); if (isGet || "HEAD".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // interceptor 拦截器进行前置预处理 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // 在handle方法中进行了请求数据的绑定，方法invoke，返回model的处理和封装等 // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException("Handler dispatch failed", err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125;核心关注的几个问题请求如何路由到具体的Controller上的方法进行处理?根据请求路径，与已知的handlerMapping进行匹配，并加入interceptors:dispatcherServlet.getHandler()最终调用AbstracteHandlerMapping.getHandlerExecutionChain(..)中进行url与handlerMapping进行匹配，并加入interceptors;扁平化的前端请求数据如何进行数据绑定？我们知道，前端的get/post等请求，会被requestServlet接受，并封装成HttpServletRequest的parameterMap中，每一项请求的数据结构都是 K-V 形的。而我们知道，像这样的形式，那么在这个中间数据如何实现数据绑定到Bean，String格式的Value 转换成各种目标格式。事实上，spring MVC将整个网络请求的处理流程进行了合理的切分,其大致的处理流程如下：12345678910111.调用匹配到的adapter.handle(..)2.然后调用invokeAndHandle(..)3.调用invokeForRequest(..)获取getMethodArgumentValues(..)获取和绑定入参;4.在具体的方法中，获取支持处理的argumentResolvers,然后调用resolveArgument(..)方法;5.在ModelAttributeMethodProcessor中调用bindRequestParameters(binder, webRequest),方法，然后再调用bind()进行bean参数的绑定；6.调用binder.convertIfNecessary(arg, parameter.getParameterType(), parameter)方法进行参数的转换；]]></content>
      <tags>
        <tag>Spring MVC</tag>
        <tag>Spring</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
</search>
